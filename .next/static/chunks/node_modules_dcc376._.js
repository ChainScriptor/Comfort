(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_dcc376._.js", {

"[project]/node_modules/next-sanity/dist/visual-editing/server-actions.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/* __next_internal_action_entry_do_not_use__ {"7f3b2aeddfe356f73fab44a2ff93e583c77c9f84ef":"revalidateRootLayout"} */ __turbopack_esm__({
    "revalidateRootLayout": (()=>revalidateRootLayout)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$webpack$2f$loaders$2f$next$2d$flight$2d$loader$2f$action$2d$client$2d$wrapper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-client-wrapper.js [app-client] (ecmascript)");
;
var revalidateRootLayout = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$webpack$2f$loaders$2f$next$2d$flight$2d$loader$2f$action$2d$client$2d$wrapper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createServerReference"])("7f3b2aeddfe356f73fab44a2ff93e583c77c9f84ef", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$webpack$2f$loaders$2f$next$2d$flight$2d$loader$2f$action$2d$client$2d$wrapper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callServer"], void 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$webpack$2f$loaders$2f$next$2d$flight$2d$loader$2f$action$2d$client$2d$wrapper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findSourceMapURL"], "revalidateRootLayout");
 //# sourceMappingURL=server-actions.js.map
}}),
"[project]/node_modules/next-sanity/dist/_chunks-es/VisualEditing.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>VisualEditing)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$navigation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/navigation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$dist$2f$visual$2d$editing$2f$server$2d$actions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next-sanity/dist/visual-editing/server-actions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@sanity/visual-editing/dist/react/index.js [app-client] (ecmascript) <locals>");
;
;
;
;
;
function pathHasPrefix(path, prefix) {
    if (typeof path != "string") return !1;
    const { pathname } = parsePath(path);
    return pathname === prefix || pathname.startsWith(`${prefix}/`);
}
function parsePath(path) {
    const hashIndex = path.indexOf("#"), queryIndex = path.indexOf("?"), hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);
    return hasQuery || hashIndex > -1 ? {
        pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),
        query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : void 0) : "",
        hash: hashIndex > -1 ? path.slice(hashIndex) : ""
    } : {
        pathname: path,
        query: "",
        hash: ""
    };
}
function addPathPrefix(path, prefix) {
    if (!path.startsWith("/") || !prefix) return path;
    if (path === "/" && prefix) return prefix;
    const { pathname, query, hash } = parsePath(path);
    return `${prefix}${pathname}${query}${hash}`;
}
function removePathPrefix(path, prefix) {
    if (!pathHasPrefix(path, prefix)) return path;
    const withoutPrefix = path.slice(prefix.length);
    return withoutPrefix.startsWith("/") ? withoutPrefix : `/${withoutPrefix}`;
}
const normalizePathTrailingSlash = (path, trailingSlash)=>{
    const { pathname, query, hash } = parsePath(path);
    return trailingSlash ? pathname.endsWith("/") ? `${pathname}${query}${hash}` : `${pathname}/${query}${hash}` : `${removeTrailingSlash(pathname)}${query}${hash}`;
};
function removeTrailingSlash(route) {
    return route.replace(/\/$/, "") || "/";
}
function VisualEditing(props) {
    const { basePath = "", components, refresh, trailingSlash = !1, zIndex } = props, router = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$navigation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRouter"])(), routerRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(router), [navigate, setNavigate] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "VisualEditing.useEffect": ()=>{
            routerRef.current = router;
        }
    }["VisualEditing.useEffect"], [
        router
    ]);
    const history = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "VisualEditing.useMemo[history]": ()=>({
                subscribe: ({
                    "VisualEditing.useMemo[history]": (_navigate)=>(setNavigate({
                            "VisualEditing.useMemo[history]": ()=>_navigate
                        }["VisualEditing.useMemo[history]"]), ({
                            "VisualEditing.useMemo[history]": ()=>setNavigate(void 0)
                        })["VisualEditing.useMemo[history]"])
                })["VisualEditing.useMemo[history]"],
                update: ({
                    "VisualEditing.useMemo[history]": (update)=>{
                        switch(update.type){
                            case "push":
                                return routerRef.current.push(removePathPrefix(update.url, basePath));
                            case "pop":
                                return routerRef.current.back();
                            case "replace":
                                return routerRef.current.replace(removePathPrefix(update.url, basePath));
                            default:
                                throw new Error(`Unknown update type: ${update.type}`);
                        }
                    }
                })["VisualEditing.useMemo[history]"]
            })
    }["VisualEditing.useMemo[history]"], [
        basePath
    ]), pathname = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$navigation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["usePathname"])(), searchParams = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$navigation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSearchParams"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "VisualEditing.useEffect": ()=>{
            navigate && navigate({
                type: "push",
                url: normalizePathTrailingSlash(addPathPrefix(`${pathname}${searchParams?.size ? `?${searchParams}` : ""}`, basePath), trailingSlash)
            });
        }
    }["VisualEditing.useEffect"], [
        basePath,
        navigate,
        pathname,
        searchParams,
        trailingSlash
    ]);
    const handleRefresh = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "VisualEditing.useCallback[handleRefresh]": (payload)=>{
            if (refresh) return refresh(payload);
            const manualFastRefresh = {
                "VisualEditing.useCallback[handleRefresh].manualFastRefresh": ()=>(console.debug("Live preview is setup, calling router.refresh() to refresh the server components without refetching cached data"), routerRef.current.refresh(), Promise.resolve())
            }["VisualEditing.useCallback[handleRefresh].manualFastRefresh"], manualFallbackRefresh = {
                "VisualEditing.useCallback[handleRefresh].manualFallbackRefresh": ()=>(console.debug("No loaders in live mode detected, or preview kit setup, revalidating root layout"), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$dist$2f$visual$2d$editing$2f$server$2d$actions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["revalidateRootLayout"])())
            }["VisualEditing.useCallback[handleRefresh].manualFallbackRefresh"], mutationFastRefresh = {
                "VisualEditing.useCallback[handleRefresh].mutationFastRefresh": ()=>(console.debug("Live preview is setup, mutation is skipped assuming its handled by the live preview"), !1)
            }["VisualEditing.useCallback[handleRefresh].mutationFastRefresh"], mutationFallbackRefresh = {
                "VisualEditing.useCallback[handleRefresh].mutationFallbackRefresh": ()=>(console.debug("No loaders in live mode detected, or preview kit setup, revalidating root layout"), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$sanity$2f$dist$2f$visual$2d$editing$2f$server$2d$actions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["revalidateRootLayout"])())
            }["VisualEditing.useCallback[handleRefresh].mutationFallbackRefresh"];
            switch(payload.source){
                case "manual":
                    return payload.livePreviewEnabled ? manualFastRefresh() : manualFallbackRefresh();
                case "mutation":
                    return payload.livePreviewEnabled ? mutationFastRefresh() : mutationFallbackRefresh();
                default:
                    throw new Error("Unknown refresh source", {
                        cause: payload
                    });
            }
        }
    }["VisualEditing.useCallback[handleRefresh]"], [
        refresh
    ]);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["VisualEditing"], {
        components,
        history,
        portal: !0,
        refresh: handleRefresh,
        zIndex
    });
}
;
 //# sourceMappingURL=VisualEditing.js.map
}}),
"[project]/node_modules/react-compiler-runtime/dist/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @lightSyntaxTransform
 * @noflow
 * @nolint
 * @preventMunge
 * @preserve-invariant-messages
 */ "use no memo";
'use strict';
var React = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function(k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function() {
                        return e[k];
                    }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}
var React__namespace = /*#__PURE__*/ _interopNamespaceDefault(React);
var _a, _b;
const { useRef, useEffect, isValidElement } = React__namespace;
const ReactSecretInternals = (_a = React__namespace.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) !== null && _a !== void 0 ? _a : React__namespace.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
const $empty = Symbol.for('react.memo_cache_sentinel');
const c = typeof ((_b = React__namespace.__COMPILER_RUNTIME) === null || _b === void 0 ? void 0 : _b.c) === 'function' ? React__namespace.__COMPILER_RUNTIME.c : function c(size) {
    return React__namespace.useMemo({
        "c.useMemo": ()=>{
            const $ = new Array(size);
            for(let ii = 0; ii < size; ii++){
                $[ii] = $empty;
            }
            $[$empty] = true;
            return $;
        }
    }["c.useMemo"], []);
};
const LazyGuardDispatcher = {};
[
    'readContext',
    'useCallback',
    'useContext',
    'useEffect',
    'useImperativeHandle',
    'useInsertionEffect',
    'useLayoutEffect',
    'useMemo',
    'useReducer',
    'useRef',
    'useState',
    'useDebugValue',
    'useDeferredValue',
    'useTransition',
    'useMutableSource',
    'useSyncExternalStore',
    'useId',
    'unstable_isNewReconciler',
    'getCacheSignal',
    'getCacheForType',
    'useCacheRefresh'
].forEach((name)=>{
    LazyGuardDispatcher[name] = ()=>{
        throw new Error(`[React] Unexpected React hook call (${name}) from a React compiled function. ` + "Check that all hooks are called directly and named according to convention ('use[A-Z]') ");
    };
});
let originalDispatcher = null;
LazyGuardDispatcher['useMemoCache'] = (count)=>{
    if (originalDispatcher == null) {
        throw new Error('React Compiler internal invariant violation: unexpected null dispatcher');
    } else {
        return originalDispatcher.useMemoCache(count);
    }
};
var GuardKind;
(function(GuardKind) {
    GuardKind[GuardKind["PushGuardContext"] = 0] = "PushGuardContext";
    GuardKind[GuardKind["PopGuardContext"] = 1] = "PopGuardContext";
    GuardKind[GuardKind["PushExpectHook"] = 2] = "PushExpectHook";
    GuardKind[GuardKind["PopExpectHook"] = 3] = "PopExpectHook";
})(GuardKind || (GuardKind = {}));
function setCurrent(newDispatcher) {
    ReactSecretInternals.ReactCurrentDispatcher.current = newDispatcher;
    return ReactSecretInternals.ReactCurrentDispatcher.current;
}
const guardFrames = [];
function $dispatcherGuard(kind) {
    const curr = ReactSecretInternals.ReactCurrentDispatcher.current;
    if (kind === GuardKind.PushGuardContext) {
        guardFrames.push(curr);
        if (guardFrames.length === 1) {
            originalDispatcher = curr;
        }
        if (curr === LazyGuardDispatcher) {
            throw new Error(`[React] Unexpected call to custom hook or component from a React compiled function. ` + "Check that (1) all hooks are called directly and named according to convention ('use[A-Z]') " + 'and (2) components are returned as JSX instead of being directly invoked.');
        }
        setCurrent(LazyGuardDispatcher);
    } else if (kind === GuardKind.PopGuardContext) {
        const lastFrame = guardFrames.pop();
        if (lastFrame == null) {
            throw new Error('React Compiler internal error: unexpected null in guard stack');
        }
        if (guardFrames.length === 0) {
            originalDispatcher = null;
        }
        setCurrent(lastFrame);
    } else if (kind === GuardKind.PushExpectHook) {
        guardFrames.push(curr);
        setCurrent(originalDispatcher);
    } else if (kind === GuardKind.PopExpectHook) {
        const lastFrame = guardFrames.pop();
        if (lastFrame == null) {
            throw new Error('React Compiler internal error: unexpected null in guard stack');
        }
        setCurrent(lastFrame);
    } else {
        throw new Error('React Compiler internal error: unreachable block' + kind);
    }
}
function $reset($) {
    for(let ii = 0; ii < $.length; ii++){
        $[ii] = $empty;
    }
}
function $makeReadOnly() {
    throw new Error('TODO: implement $makeReadOnly in react-compiler-runtime');
}
const renderCounterRegistry = new Map();
function clearRenderCounterRegistry() {
    for (const counters of renderCounterRegistry.values()){
        counters.forEach((counter)=>{
            counter.count = 0;
        });
    }
}
function registerRenderCounter(name, val) {
    let counters = renderCounterRegistry.get(name);
    if (counters == null) {
        counters = new Set();
        renderCounterRegistry.set(name, counters);
    }
    counters.add(val);
}
function removeRenderCounter(name, val) {
    const counters = renderCounterRegistry.get(name);
    if (counters == null) {
        return;
    }
    counters.delete(val);
}
function useRenderCounter(name) {
    const val = useRef(null);
    if (val.current != null) {
        val.current.count += 1;
    }
    useEffect({
        "useRenderCounter.useEffect": ()=>{
            if (val.current == null) {
                const counter = {
                    count: 0
                };
                registerRenderCounter(name, counter);
                val.current = counter;
            }
            return ({
                "useRenderCounter.useEffect": ()=>{
                    if (val.current !== null) {
                        removeRenderCounter(name, val.current);
                    }
                }
            })["useRenderCounter.useEffect"];
        }
    }["useRenderCounter.useEffect"]);
}
const seenErrors = new Set();
function $structuralCheck(oldValue, newValue, variableName, fnName, kind, loc) {
    function error(l, r, path, depth) {
        const str = `${fnName}:${loc} [${kind}] ${variableName}${path} changed from ${l} to ${r} at depth ${depth}`;
        if (seenErrors.has(str)) {
            return;
        }
        seenErrors.add(str);
        console.error(str);
    }
    const depthLimit = 2;
    function recur(oldValue, newValue, path, depth) {
        if (depth > depthLimit) {
            return;
        } else if (oldValue === newValue) {
            return;
        } else if (typeof oldValue !== typeof newValue) {
            error(`type ${typeof oldValue}`, `type ${typeof newValue}`, path, depth);
        } else if (typeof oldValue === 'object') {
            const oldArray = Array.isArray(oldValue);
            const newArray = Array.isArray(newValue);
            if (oldValue === null && newValue !== null) {
                error('null', `type ${typeof newValue}`, path, depth);
            } else if (newValue === null) {
                error(`type ${typeof oldValue}`, 'null', path, depth);
            } else if (oldValue instanceof Map) {
                if (!(newValue instanceof Map)) {
                    error(`Map instance`, `other value`, path, depth);
                } else if (oldValue.size !== newValue.size) {
                    error(`Map instance with size ${oldValue.size}`, `Map instance with size ${newValue.size}`, path, depth);
                } else {
                    for (const [k, v] of oldValue){
                        if (!newValue.has(k)) {
                            error(`Map instance with key ${k}`, `Map instance without key ${k}`, path, depth);
                        } else {
                            recur(v, newValue.get(k), `${path}.get(${k})`, depth + 1);
                        }
                    }
                }
            } else if (newValue instanceof Map) {
                error('other value', `Map instance`, path, depth);
            } else if (oldValue instanceof Set) {
                if (!(newValue instanceof Set)) {
                    error(`Set instance`, `other value`, path, depth);
                } else if (oldValue.size !== newValue.size) {
                    error(`Set instance with size ${oldValue.size}`, `Set instance with size ${newValue.size}`, path, depth);
                } else {
                    for (const v of newValue){
                        if (!oldValue.has(v)) {
                            error(`Set instance without element ${v}`, `Set instance with element ${v}`, path, depth);
                        }
                    }
                }
            } else if (newValue instanceof Set) {
                error('other value', `Set instance`, path, depth);
            } else if (oldArray || newArray) {
                if (oldArray !== newArray) {
                    error(`type ${oldArray ? 'array' : 'object'}`, `type ${newArray ? 'array' : 'object'}`, path, depth);
                } else if (oldValue.length !== newValue.length) {
                    error(`array with length ${oldValue.length}`, `array with length ${newValue.length}`, path, depth);
                } else {
                    for(let ii = 0; ii < oldValue.length; ii++){
                        recur(oldValue[ii], newValue[ii], `${path}[${ii}]`, depth + 1);
                    }
                }
            } else if (isValidElement(oldValue) || isValidElement(newValue)) {
                if (isValidElement(oldValue) !== isValidElement(newValue)) {
                    error(`type ${isValidElement(oldValue) ? 'React element' : 'object'}`, `type ${isValidElement(newValue) ? 'React element' : 'object'}`, path, depth);
                } else if (oldValue.type !== newValue.type) {
                    error(`React element of type ${oldValue.type}`, `React element of type ${newValue.type}`, path, depth);
                } else {
                    recur(oldValue.props, newValue.props, `[props of ${path}]`, depth + 1);
                }
            } else {
                for(const key in newValue){
                    if (!(key in oldValue)) {
                        error(`object without key ${key}`, `object with key ${key}`, path, depth);
                    }
                }
                for(const key in oldValue){
                    if (!(key in newValue)) {
                        error(`object with key ${key}`, `object without key ${key}`, path, depth);
                    } else {
                        recur(oldValue[key], newValue[key], `${path}.${key}`, depth + 1);
                    }
                }
            }
        } else if (typeof oldValue === 'function') {
            return;
        } else if (isNaN(oldValue) || isNaN(newValue)) {
            if (isNaN(oldValue) !== isNaN(newValue)) {
                error(`${isNaN(oldValue) ? 'NaN' : 'non-NaN value'}`, `${isNaN(newValue) ? 'NaN' : 'non-NaN value'}`, path, depth);
            }
        } else if (oldValue !== newValue) {
            error(oldValue, newValue, path, depth);
        }
    }
    recur(oldValue, newValue, '', 0);
}
exports.$dispatcherGuard = $dispatcherGuard;
exports.$makeReadOnly = $makeReadOnly;
exports.$reset = $reset;
exports.$structuralCheck = $structuralCheck;
exports.c = c;
exports.clearRenderCounterRegistry = clearRenderCounterRegistry;
exports.renderCounterRegistry = renderCounterRegistry;
exports.useRenderCounter = useRenderCounter; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@sanity/visual-editing/node_modules/@sanity/mutate/dist/_chunks-es/parse.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "parse": (()=>parse)
});
function parse(path) {
    return path.split(/[[.\]]/g).filter(Boolean).map((seg)=>seg.includes("==") ? parseSegment(seg) : coerce(seg));
}
const IS_NUMERIC = /^-?\d+$/;
function unquote(str) {
    return str.replace(/^['"]/, "").replace(/['"]$/, "");
}
function parseSegment(segment) {
    const [key, value] = segment.split("==");
    if (key !== "_key") throw new Error(`Currently only "_key" is supported as path segment. Found ${key}`);
    if (typeof value > "u") throw new Error('Invalid path segment, expected `key=="value"`');
    return {
        _key: unquote(value)
    };
}
function coerce(segment) {
    return IS_NUMERIC.test(segment) ? Number(segment) : segment;
}
;
 //# sourceMappingURL=parse.js.map
}}),
"[project]/node_modules/@sanity/visual-editing/node_modules/@sanity/mutate/dist/_chunks-es/stringify.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "isArrayElement": (()=>isArrayElement),
    "isElementEqual": (()=>isElementEqual),
    "isEqual": (()=>isEqual),
    "isIndexElement": (()=>isIndexElement),
    "isKeyElement": (()=>isKeyElement),
    "isKeyedElement": (()=>isKeyedElement),
    "isPropertyElement": (()=>isPropertyElement),
    "startsWith": (()=>startsWith),
    "stringify": (()=>stringify)
});
function safeGetElementAt(array, index) {
    if (index < 0 || index >= array.length) throw new Error("Index out of bounds");
    return array[index];
}
function startsWith(parentPath, path) {
    return parentPath.length <= path.length && parentPath.every((segment, i)=>isElementEqual(segment, safeGetElementAt(path, i)));
}
function isEqual(path, otherPath) {
    return path.length === otherPath.length && path.every((segment, i)=>isElementEqual(segment, safeGetElementAt(path, i)));
}
function isElementEqual(segmentA, segmentB) {
    return isKeyElement(segmentA) && isKeyElement(segmentB) ? segmentA._key === segmentB._key : isIndexElement(segmentA) ? Number(segmentA) === Number(segmentB) : segmentA === segmentB;
}
function isKeyElement(segment) {
    return typeof segment?._key == "string";
}
function isIndexElement(segment) {
    return typeof segment == "number";
}
function isKeyedElement(element) {
    return typeof element == "object" && "_key" in element && typeof element._key == "string";
}
function isArrayElement(element) {
    return typeof element == "number" || isKeyedElement(element);
}
function isPropertyElement(element) {
    return typeof element == "string";
}
const IS_DOTTABLE = /^[a-z_$]+/;
function stringifySegment(segment, hasLeading) {
    return Array.isArray(segment) ? `[${segment[0]}:${segment[1] || ""}]` : typeof segment == "number" ? `[${segment}]` : isKeyedElement(segment) ? `[_key==${JSON.stringify(segment._key)}]` : typeof segment == "string" && IS_DOTTABLE.test(segment) ? hasLeading ? segment : `.${segment}` : `['${segment}']`;
}
function stringify(pathArray) {
    return pathArray.map((segment, i)=>stringifySegment(segment, i === 0)).join("");
}
;
 //# sourceMappingURL=stringify.js.map
}}),
"[project]/node_modules/@sanity/visual-editing/node_modules/@sanity/mutate/dist/_chunks-es/decode.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "decode": (()=>decode),
    "decodeAll": (()=>decodeAll)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/visual-editing/node_modules/@sanity/mutate/dist/_chunks-es/parse.js [app-client] (ecmascript)");
;
function isCreateIfNotExistsMutation(sanityMutation) {
    return "createIfNotExists" in sanityMutation;
}
function isCreateOrReplaceMutation(sanityMutation) {
    return "createOrReplace" in sanityMutation;
}
function isCreateMutation(sanityMutation) {
    return "create" in sanityMutation;
}
function isDeleteMutation(sanityMutation) {
    return "delete" in sanityMutation;
}
function isPatchMutation(sanityMutation) {
    return "patch" in sanityMutation;
}
function isSetPatch(sanityPatch) {
    return "set" in sanityPatch;
}
function isSetIfMissingPatch(sanityPatch) {
    return "setIfMissing" in sanityPatch;
}
function isUnsetPatch(sanityPatch) {
    return "unset" in sanityPatch;
}
function isIncPatch(sanityPatch) {
    return "inc" in sanityPatch;
}
function isDecPatch(sanityPatch) {
    return "inc" in sanityPatch;
}
function isInsertPatch(sanityPatch) {
    return "insert" in sanityPatch;
}
function decodeAll(sanityMutations) {
    return sanityMutations.map(decodeMutation);
}
function decode(encodedMutation) {
    return decodeMutation(encodedMutation);
}
function decodeMutation(encodedMutation) {
    if (isCreateIfNotExistsMutation(encodedMutation)) return {
        type: "createIfNotExists",
        document: encodedMutation.createIfNotExists
    };
    if (isCreateOrReplaceMutation(encodedMutation)) return {
        type: "createOrReplace",
        document: encodedMutation.createOrReplace
    };
    if (isCreateMutation(encodedMutation)) return {
        type: "create",
        document: encodedMutation.create
    };
    if (isDeleteMutation(encodedMutation)) return {
        id: encodedMutation.delete.id,
        type: "delete"
    };
    if (isPatchMutation(encodedMutation)) return {
        type: "patch",
        id: encodedMutation.patch.id,
        patches: decodeNodePatches(encodedMutation.patch)
    };
    throw new Error(`Unknown mutation: ${JSON.stringify(encodedMutation)}`);
}
const POSITION_KEYS = [
    "before",
    "replace",
    "after"
];
function getInsertPosition(insert) {
    const positions = POSITION_KEYS.filter((k)=>k in insert);
    if (positions.length > 1) throw new Error(`Insert patch is ambiguous. Should only contain one of: ${POSITION_KEYS.join(", ")}, instead found ${positions.join(", ")}`);
    return positions[0];
}
function decodeNodePatches(patch) {
    return [
        ...getSetPatches(patch),
        ...getSetIfMissingPatches(patch),
        ...getUnsetPatches(patch),
        ...getIncPatches(patch),
        ...getDecPatches(patch),
        ...getInsertPatches(patch)
    ];
}
function getSetPatches(patch) {
    return isSetPatch(patch) ? Object.keys(patch.set).map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "set",
                value: patch.set[path]
            }
        })) : [];
}
function getSetIfMissingPatches(patch) {
    return isSetIfMissingPatch(patch) ? Object.keys(patch.setIfMissing).map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "setIfMissing",
                value: patch.setIfMissing[path]
            }
        })) : [];
}
function getUnsetPatches(patch) {
    return isUnsetPatch(patch) ? patch.unset.map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "unset"
            }
        })) : [];
}
function getIncPatches(patch) {
    return isIncPatch(patch) ? Object.keys(patch.inc).map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "inc",
                amount: patch.inc[path]
            }
        })) : [];
}
function getDecPatches(patch) {
    return isDecPatch(patch) ? Object.keys(patch.dec).map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "dec",
                amount: patch.dec[path]
            }
        })) : [];
}
function getInsertPatches(patch) {
    if (!isInsertPatch(patch)) return [];
    const position = getInsertPosition(patch.insert);
    if (!position) throw new Error("Insert patch missing position");
    const path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(patch.insert[position]), referenceItem = path.pop(), op = position === "replace" ? {
        type: "insert",
        position,
        referenceItem,
        items: patch.insert.items
    } : {
        type: "insert",
        position,
        referenceItem,
        items: patch.insert.items
    };
    return [
        {
            path,
            op
        }
    ];
}
;
 //# sourceMappingURL=decode.js.map
}}),
"[project]/node_modules/@sanity/visual-editing/node_modules/@sanity/mutate/dist/_chunks-es/encode.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "encode": (()=>encode),
    "encodeAll": (()=>encodeAll),
    "encodeMutation": (()=>encodeMutation),
    "encodeTransaction": (()=>encodeTransaction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/visual-editing/node_modules/@sanity/mutate/dist/_chunks-es/stringify.js [app-client] (ecmascript)");
;
function encode(mutation) {
    return encodeMutation(mutation);
}
function encodeAll(mutations) {
    return mutations.flatMap(encode);
}
function encodeTransaction(transaction) {
    return {
        transactionId: transaction.id,
        mutations: encodeAll(transaction.mutations)
    };
}
function encodeMutation(mutation) {
    if (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") return {
        [mutation.type]: mutation.document
    };
    if (mutation.type === "delete") return {
        delete: {
            id: mutation.id
        }
    };
    const ifRevisionID = mutation.options?.ifRevision;
    return mutation.patches.map((patch)=>({
            patch: {
                id: mutation.id,
                ...ifRevisionID && {
                    ifRevisionID
                },
                ...patchToSanity(patch)
            }
        }));
}
function patchToSanity(patch) {
    const { path, op } = patch;
    if (op.type === "unset") return {
        unset: [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path)
        ]
    };
    if (op.type === "insert") return {
        insert: {
            [op.position]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])([
                ...path,
                op.referenceItem
            ]),
            items: op.items
        }
    };
    if (op.type === "diffMatchPatch") return {
        diffMatchPatch: {
            [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path)]: op.value
        }
    };
    if (op.type === "inc") return {
        inc: {
            [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path)]: op.amount
        }
    };
    if (op.type === "dec") return {
        dec: {
            [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path)]: op.amount
        }
    };
    if (op.type === "set" || op.type === "setIfMissing") return {
        [op.type]: {
            [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path)]: op.value
        }
    };
    if (op.type === "truncate") {
        const range = [
            op.startIndex,
            typeof op.endIndex == "number" ? op.endIndex : ""
        ].join(":");
        return {
            unset: [
                `${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path)}[${range}]`
            ]
        };
    }
    if (op.type === "upsert") return {
        unset: op.items.map((item)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])([
                ...path,
                {
                    _key: item._key
                }
            ])),
        insert: {
            [op.position]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])([
                ...path,
                op.referenceItem
            ]),
            items: op.items
        }
    };
    if (op.type === "assign") return {
        set: Object.fromEntries(Object.keys(op.value).map((key)=>[
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path.concat(key)),
                op.value[key]
            ]))
    };
    if (op.type === "unassign") return {
        unset: op.keys.map((key)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path.concat(key)))
    };
    if (op.type === "replace") return {
        insert: {
            replace: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path.concat(op.referenceItem)),
            items: op.items
        }
    };
    if (op.type === "remove") return {
        unset: [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path.concat(op.referenceItem))
        ]
    };
    throw new Error(`Unknown operation type ${op.type}`);
}
;
 //# sourceMappingURL=encode.js.map
}}),
"[project]/node_modules/@sanity/visual-editing/node_modules/@sanity/mutate/dist/_chunks-es/arrify.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "arrify": (()=>arrify)
});
function arrify(val) {
    return Array.isArray(val) ? val : [
        val
    ];
}
;
 //# sourceMappingURL=arrify.js.map
}}),
"[project]/node_modules/@sanity/visual-editing/node_modules/@sanity/mutate/dist/_chunks-es/isObject.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "isObject": (()=>isObject)
});
function isObject(val) {
    return val !== null && typeof val == "object" && !Array.isArray(val);
}
;
 //# sourceMappingURL=isObject.js.map
}}),
"[project]/node_modules/@sanity/visual-editing/node_modules/@sanity/mutate/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CompactEncoder": (()=>index$1),
    "CompactFormatter": (()=>compact),
    "SanityEncoder": (()=>index),
    "append": (()=>append),
    "assign": (()=>assign),
    "at": (()=>at),
    "autoKeys": (()=>autoKeys),
    "create": (()=>create),
    "createIfNotExists": (()=>createIfNotExists),
    "createOrReplace": (()=>createOrReplace),
    "dec": (()=>dec),
    "del": (()=>del),
    "delete_": (()=>delete_),
    "destroy": (()=>destroy),
    "diffMatchPatch": (()=>diffMatchPatch),
    "inc": (()=>inc),
    "insert": (()=>insert),
    "insertAfter": (()=>insertAfter),
    "insertBefore": (()=>insertBefore),
    "patch": (()=>patch),
    "prepend": (()=>prepend),
    "remove": (()=>remove),
    "replace": (()=>replace),
    "set": (()=>set),
    "setIfMissing": (()=>setIfMissing),
    "truncate": (()=>truncate),
    "unassign": (()=>unassign),
    "unset": (()=>unset),
    "upsert": (()=>upsert)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/visual-editing/node_modules/@sanity/mutate/dist/_chunks-es/parse.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/visual-editing/node_modules/@sanity/mutate/dist/_chunks-es/stringify.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/visual-editing/node_modules/@sanity/mutate/dist/_chunks-es/decode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/visual-editing/node_modules/@sanity/mutate/dist/_chunks-es/encode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/visual-editing/node_modules/@sanity/mutate/dist/_chunks-es/arrify.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$isObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/visual-editing/node_modules/@sanity/mutate/dist/_chunks-es/isObject.js [app-client] (ecmascript)");
;
;
;
;
;
;
function decode(mutations) {
    return mutations.map(decodeMutation);
}
function decodeMutation(mutation) {
    const [type] = mutation;
    if (type === "delete") {
        const [, id] = mutation;
        return {
            id,
            type
        };
    } else if (type === "create") {
        const [, document] = mutation;
        return {
            type,
            document
        };
    } else if (type === "createIfNotExists") {
        const [, document] = mutation;
        return {
            type,
            document
        };
    } else if (type === "createOrReplace") {
        const [, document] = mutation;
        return {
            type,
            document
        };
    } else if (type === "patch") return decodePatchMutation(mutation);
    throw new Error(`Unrecognized mutation: ${JSON.stringify(mutation)}`);
}
function decodePatchMutation(mutation) {
    const [, type, id, serializedPath, , revisionId] = mutation, path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(serializedPath);
    if (type === "dec" || type === "inc") {
        const [, , , , [amount]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "inc",
                        amount
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "unset") return {
        type: "patch",
        id,
        patches: [
            {
                path,
                op: {
                    type: "unset"
                }
            }
        ],
        ...createOpts(revisionId)
    };
    if (type === "insert") {
        const [, , , , [position, ref, items]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "insert",
                        position,
                        items,
                        referenceItem: typeof ref == "string" ? {
                            _key: ref
                        } : ref
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "set") {
        const [, , , , [value]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "set",
                        value
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "setIfMissing") {
        const [, , , , [value]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "setIfMissing",
                        value
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "diffMatchPatch") {
        const [, , , , [value]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "diffMatchPatch",
                        value
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "truncate") {
        const [, , , , [startIndex, endIndex]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "truncate",
                        startIndex,
                        endIndex
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "assign") {
        const [, , , , [value]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "assign",
                        value
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "replace") {
        const [, , , , [ref, items]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "replace",
                        items,
                        referenceItem: decodeItemRef(ref)
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "upsert") {
        const [, , , , [position, referenceItem, items]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "upsert",
                        items,
                        referenceItem: decodeItemRef(referenceItem),
                        position
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    throw new Error(`Invalid mutation type: ${type}`);
}
function decodeItemRef(ref) {
    return typeof ref == "string" ? {
        _key: ref
    } : ref;
}
function createOpts(revisionId) {
    return revisionId ? {
        options: {
            ifRevision: revisionId
        }
    } : null;
}
function encode(mutations) {
    return mutations.flatMap((m)=>encodeMutation$1(m));
}
function encodeItemRef$1(ref) {
    return typeof ref == "number" ? ref : ref._key;
}
function encodeMutation$1(mutation) {
    if (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") return [
        [
            mutation.type,
            mutation.document
        ]
    ];
    if (mutation.type === "delete") return [
        [
            "delete",
            mutation.id
        ]
    ];
    if (mutation.type === "patch") return mutation.patches.map((patch2)=>maybeAddRevision(mutation.options?.ifRevision, encodePatchMutation(mutation.id, patch2)));
    throw new Error(`Invalid mutation type: ${mutation.type}`);
}
function encodePatchMutation(id, patch2) {
    const { op } = patch2, path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(patch2.path);
    if (op.type === "unset") return [
        "patch",
        "unset",
        id,
        path,
        []
    ];
    if (op.type === "diffMatchPatch") return [
        "patch",
        "diffMatchPatch",
        id,
        path,
        [
            op.value
        ]
    ];
    if (op.type === "inc" || op.type === "dec") return [
        "patch",
        op.type,
        id,
        path,
        [
            op.amount
        ]
    ];
    if (op.type === "set") return [
        "patch",
        op.type,
        id,
        path,
        [
            op.value
        ]
    ];
    if (op.type === "setIfMissing") return [
        "patch",
        op.type,
        id,
        path,
        [
            op.value
        ]
    ];
    if (op.type === "insert") return [
        "patch",
        "insert",
        id,
        path,
        [
            op.position,
            encodeItemRef$1(op.referenceItem),
            op.items
        ]
    ];
    if (op.type === "upsert") return [
        "patch",
        "upsert",
        id,
        path,
        [
            op.position,
            encodeItemRef$1(op.referenceItem),
            op.items
        ]
    ];
    if (op.type === "assign") return [
        "patch",
        "assign",
        id,
        path,
        [
            op.value
        ]
    ];
    if (op.type === "unassign") return [
        "patch",
        "assign",
        id,
        path,
        [
            op.keys
        ]
    ];
    if (op.type === "replace") return [
        "patch",
        "replace",
        id,
        path,
        [
            encodeItemRef$1(op.referenceItem),
            op.items
        ]
    ];
    if (op.type === "truncate") return [
        "patch",
        "truncate",
        id,
        path,
        [
            op.startIndex,
            op.endIndex
        ]
    ];
    if (op.type === "remove") return [
        "patch",
        "remove",
        id,
        path,
        [
            encodeItemRef$1(op.referenceItem)
        ]
    ];
    throw new Error(`Invalid operation type: ${op.type}`);
}
function maybeAddRevision(revision, mut) {
    const [mutType, patchType, id, path, args] = mut;
    return revision ? [
        mutType,
        patchType,
        id,
        path,
        args,
        revision
    ] : mut;
}
var index$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    decode,
    encode
}), index = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    decode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"],
    decodeAll: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeAll"],
    encode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"],
    encodeAll: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeAll"],
    encodeMutation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeMutation"],
    encodeTransaction: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeTransaction"]
});
function format(mutations) {
    return mutations.flatMap((m)=>encodeMutation(m)).join(`
`);
}
function encodeItemRef(ref) {
    return typeof ref == "number" ? ref : ref._key;
}
function encodeMutation(mutation) {
    if (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") return [
        mutation.type,
        ": ",
        JSON.stringify(mutation.document)
    ].join("");
    if (mutation.type === "delete") return [
        "delete ",
        mutation.id
    ].join(": ");
    if (mutation.type === "patch") {
        const ifRevision = mutation.options?.ifRevision;
        return [
            "patch",
            " ",
            `id=${mutation.id}`,
            ifRevision ? ` (if revision==${ifRevision})` : "",
            `:
`,
            mutation.patches.map((nodePatch)=>`  ${formatPatchMutation(nodePatch)}`).join(`
`)
        ].join("");
    }
    throw new Error(`Invalid mutation type: ${mutation.type}`);
}
function formatPatchMutation(patch2) {
    const { op } = patch2, path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(patch2.path);
    if (op.type === "unset") return [
        path,
        "unset()"
    ].join(": ");
    if (op.type === "diffMatchPatch") return [
        path,
        `diffMatchPatch(${op.value})`
    ].join(": ");
    if (op.type === "inc" || op.type === "dec") return [
        path,
        `${op.type}(${op.amount})`
    ].join(": ");
    if (op.type === "set" || op.type === "setIfMissing") return [
        path,
        `${op.type}(${JSON.stringify(op.value)})`
    ].join(": ");
    if (op.type === "assign") return [
        path,
        `${op.type}(${JSON.stringify(op.value)})`
    ].join(": ");
    if (op.type === "unassign") return [
        path,
        `${op.type}(${JSON.stringify(op.keys)})`
    ].join(": ");
    if (op.type === "insert" || op.type === "upsert") return [
        path,
        `${op.type}(${op.position}, ${encodeItemRef(op.referenceItem)}, ${JSON.stringify(op.items)})`
    ].join(": ");
    if (op.type === "replace") return [
        path,
        `replace(${encodeItemRef(op.referenceItem)}, ${JSON.stringify(op.items)})`
    ].join(": ");
    if (op.type === "truncate") return [
        path,
        `truncate(${op.startIndex}, ${op.endIndex}`
    ].join(": ");
    if (op.type === "remove") return [
        path,
        `remove(${encodeItemRef(op.referenceItem)})`
    ].join(": ");
    throw new Error(`Invalid operation type: ${op.type}`);
}
var compact = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    format
});
const set = (value)=>({
        type: "set",
        value
    }), assign = (value)=>({
        type: "assign",
        value
    }), unassign = (keys)=>({
        type: "unassign",
        keys
    }), setIfMissing = (value)=>({
        type: "setIfMissing",
        value
    }), unset = ()=>({
        type: "unset"
    }), inc = (amount = 1)=>({
        type: "inc",
        amount
    }), dec = (amount = 1)=>({
        type: "dec",
        amount
    }), diffMatchPatch = (value)=>({
        type: "diffMatchPatch",
        value
    });
function insert(items, position, indexOrReferenceItem) {
    return {
        type: "insert",
        referenceItem: indexOrReferenceItem,
        position,
        items: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrify"])(items)
    };
}
function append(items) {
    return insert(items, "after", -1);
}
function prepend(items) {
    return insert(items, "before", 0);
}
function insertBefore(items, indexOrReferenceItem) {
    return insert(items, "before", indexOrReferenceItem);
}
const insertAfter = (items, indexOrReferenceItem)=>insert(items, "after", indexOrReferenceItem);
function truncate(startIndex, endIndex) {
    return {
        type: "truncate",
        startIndex,
        endIndex
    };
}
function replace(items, referenceItem) {
    return {
        type: "replace",
        referenceItem,
        items: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrify"])(items)
    };
}
function remove(referenceItem) {
    return {
        type: "remove",
        referenceItem
    };
}
function upsert(items, position, referenceItem) {
    return {
        type: "upsert",
        items: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrify"])(items),
        referenceItem,
        position
    };
}
function autoKeys(generateKey) {
    const ensureKeys = createEnsureKeys(generateKey), insert$1 = (position, referenceItem, items)=>insert(ensureKeys(items), position, referenceItem), upsert$1 = (items, position, referenceItem)=>upsert(ensureKeys(items), position, referenceItem), replace$1 = (items, position, referenceItem)=>replace(ensureKeys(items), referenceItem), insertBefore2 = (ref, items)=>insert$1("before", ref, items);
    return {
        insert: insert$1,
        upsert: upsert$1,
        replace: replace$1,
        insertBefore: insertBefore2,
        prepend: (items)=>insertBefore2(0, items),
        insertAfter: (ref, items)=>insert$1("after", ref, items),
        append: (items)=>insert$1("after", -1, items)
    };
}
function hasKey(item) {
    return "_key" in item;
}
function createEnsureKeys(generateKey) {
    return (array)=>{
        let didModify = !1;
        const withKeys = array.map((item)=>needsKey(item) ? (didModify = !0, {
                ...item,
                _key: generateKey(item)
            }) : item);
        return didModify ? withKeys : array;
    };
}
function needsKey(arrayItem) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$isObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(arrayItem) && !hasKey(arrayItem);
}
function create(document) {
    return {
        type: "create",
        document
    };
}
function patch(id, patches, options) {
    return {
        type: "patch",
        id,
        patches: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrify"])(patches),
        ...options ? {
            options
        } : {}
    };
}
function at(path, operation) {
    return {
        path: typeof path == "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(path) : path,
        op: operation
    };
}
function createIfNotExists(document) {
    return {
        type: "createIfNotExists",
        document
    };
}
function createOrReplace(document) {
    return {
        type: "createOrReplace",
        document
    };
}
function delete_(id) {
    return {
        type: "delete",
        id
    };
}
const del = delete_, destroy = delete_;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@sanity/visual-editing/node_modules/@sanity/mutate/dist/_unstable_machine.browser.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "applyMutations": (()=>applyMutations),
    "commit": (()=>commit),
    "createSharedListener": (()=>createSharedListener),
    "documentMutatorMachine": (()=>documentMutatorMachine),
    "rebase": (()=>rebase),
    "squashDMPStrings": (()=>squashDMPStrings),
    "squashMutationGroups": (()=>squashMutationGroups),
    "toTransactions": (()=>toTransactions)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/diff-match-patch/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$groupBy$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__groupBy$3e$__ = __turbopack_import__("[project]/node_modules/lodash-es/groupBy.js [app-client] (ecmascript) <export default as groupBy>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$share$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/operators/share.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/operators/filter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/observable/merge.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$shareReplay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/xstate/dist/xstate.development.esm.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__ = __turbopack_import__("[project]/node_modules/xstate/dist/log-ef30c65f.development.esm.js [app-client] (ecmascript) <export a as assign>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$1db27a82$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__O__as__raise$3e$__ = __turbopack_import__("[project]/node_modules/xstate/dist/raise-1db27a82.development.esm.js [app-client] (ecmascript) <export O as raise>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$1db27a82$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__P__as__spawnChild$3e$__ = __turbopack_import__("[project]/node_modules/xstate/dist/raise-1db27a82.development.esm.js [app-client] (ecmascript) <export P as spawnChild>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$1db27a82$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__R__as__stopChild$3e$__ = __turbopack_import__("[project]/node_modules/xstate/dist/raise-1db27a82.development.esm.js [app-client] (ecmascript) <export R as stopChild>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__b__as__enqueueActions$3e$__ = __turbopack_import__("[project]/node_modules/xstate/dist/log-ef30c65f.development.esm.js [app-client] (ecmascript) <export b as enqueueActions>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__s__as__sendParent$3e$__ = __turbopack_import__("[project]/node_modules/xstate/dist/log-ef30c65f.development.esm.js [app-client] (ecmascript) <export s as sendParent>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/xstate/actors/dist/xstate-actors.development.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$defer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/observable/defer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$observeOn$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/operators/observeOn.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$asap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/scheduler/asap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mendoza$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/mendoza/dist/index.js [app-client] (ecmascript)");
;
;
;
;
;
function getMutationDocumentId(mutation) {
    if (mutation.type === "patch") return mutation.id;
    if (mutation.type === "create") return mutation.document._id;
    if (mutation.type === "delete") return mutation.id;
    if (mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") return mutation.document._id;
    throw new Error("Invalid mutation type");
}
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let nanoid = (size = 21)=>{
    let id = "", bytes = crypto.getRandomValues(new Uint8Array(size));
    for(; size--;)id += urlAlphabet[bytes[size] & 63];
    return id;
};
function safeGetElementAt(array, index) {
    if (index < 0 || index >= array.length) throw new Error("Index out of bounds");
    return array[index];
}
function startsWith(parentPath, path) {
    return parentPath.length <= path.length && parentPath.every((segment, i)=>isElementEqual(segment, safeGetElementAt(path, i)));
}
function isElementEqual(segmentA, segmentB) {
    return isKeyElement(segmentA) && isKeyElement(segmentB) ? segmentA._key === segmentB._key : isIndexElement(segmentA) ? Number(segmentA) === Number(segmentB) : segmentA === segmentB;
}
function isKeyElement(segment) {
    return typeof segment?._key == "string";
}
function isIndexElement(segment) {
    return typeof segment == "number";
}
function isKeyedElement(element) {
    return typeof element == "object" && "_key" in element && typeof element._key == "string";
}
function isArrayElement(element) {
    return typeof element == "number" || isKeyedElement(element);
}
function isPropertyElement(element) {
    return typeof element == "string";
}
function getAtPath(path, value) {
    if (path.length === 0) return value;
    let current = value;
    for (const head of path){
        if (isArrayElement(head)) {
            if (!Array.isArray(current)) return;
            if (isKeyedElement(head)) {
                current = current.find((item)=>item._key === head._key);
                continue;
            }
            current = current[head];
            continue;
        }
        current = current[head];
    }
    return current;
}
const IS_DOTTABLE = /^[a-z_$]+/;
function stringifySegment(segment, hasLeading) {
    return Array.isArray(segment) ? `[${segment[0]}:${segment[1] || ""}]` : typeof segment == "number" ? `[${segment}]` : isKeyedElement(segment) ? `[_key==${JSON.stringify(segment._key)}]` : typeof segment == "string" && IS_DOTTABLE.test(segment) ? hasLeading ? segment : `.${segment}` : `['${segment}']`;
}
function stringify(pathArray) {
    return pathArray.map((segment, i)=>stringifySegment(segment, i === 0)).join("");
}
function isObject(val) {
    return val !== null && typeof val == "object" && !Array.isArray(val);
}
function keyOf(value) {
    return value !== null && typeof value == "object" && typeof value._key == "string" && value._key || null;
}
function findTargetIndex(array, pathSegment) {
    if (typeof pathSegment == "number") return normalizeIndex(array.length, pathSegment);
    if (isKeyedElement(pathSegment)) {
        const idx = array.findIndex((value)=>keyOf(value) === pathSegment._key);
        return idx === -1 ? null : idx;
    }
    throw new Error(`Expected path segment to be addressing a single array item either by numeric index or by '_key'. Instead saw ${JSON.stringify(pathSegment)}`);
}
function getTargetIdx(position, index) {
    return position === "before" ? index : index + 1;
}
function normalizeIndex(length, index) {
    if (length === 0 && (index === -1 || index === 0)) return 0;
    const normalized = index < 0 ? length + index : index;
    return normalized >= length || normalized < 0 ? null : normalized;
}
function splice(arr, start, deleteCount, items) {
    const copy = arr.slice();
    return copy.splice(start, deleteCount, ...items || []), copy;
}
function insert(op, currentValue) {
    if (!Array.isArray(currentValue)) throw new TypeError('Cannot apply "insert()" on non-array value');
    const index = findTargetIndex(currentValue, op.referenceItem);
    if (index === null) throw new Error(`Found no matching array element to insert ${op.position}`);
    return currentValue.length === 0 ? op.items : splice(currentValue, getTargetIdx(op.position, index), 0, op.items);
}
function upsert(op, currentValue) {
    if (!Array.isArray(currentValue)) throw new TypeError('Cannot apply "upsert()" on non-array value');
    if (op.items.length === 0) return currentValue;
    const replaceItemsMap = [], insertItems = [];
    if (op.items.forEach((itemToBeUpserted, i)=>{
        const existingIndex = currentValue.findIndex((existingItem)=>existingItem?._key === itemToBeUpserted._key);
        existingIndex >= 0 ? replaceItemsMap[existingIndex] = i : insertItems.push(itemToBeUpserted);
    }), replaceItemsMap.length === 0 && insertItems.length == 0) return currentValue;
    const next = [
        ...currentValue
    ];
    for (const i of replaceItemsMap)next[i] = op.items[replaceItemsMap[i]];
    return insert({
        type: "insert",
        items: insertItems,
        referenceItem: op.referenceItem,
        position: op.position
    }, next);
}
function replace(op, currentValue) {
    if (!Array.isArray(currentValue)) throw new TypeError('Cannot apply "replace()" on non-array value');
    const index = findTargetIndex(currentValue, op.referenceItem);
    if (index === null) throw new Error("Found no matching array element to replace");
    return splice(currentValue, index, op.items.length, op.items);
}
function remove(op, currentValue) {
    if (!Array.isArray(currentValue)) throw new TypeError('Cannot apply "remove()" on non-array value');
    const index = findTargetIndex(currentValue, op.referenceItem);
    if (index === null) throw new Error("Found no matching array element to replace");
    return splice(currentValue, index, 1, []);
}
function truncate(op, currentValue) {
    if (!Array.isArray(currentValue)) throw new TypeError('Cannot apply "truncate()" on non-array value');
    return typeof op.endIndex == "number" ? currentValue.slice(0, op.startIndex).concat(currentValue.slice(op.endIndex)) : currentValue.slice(0, op.startIndex);
}
function set(op, currentValue) {
    return op.value;
}
function setIfMissing(op, currentValue) {
    return currentValue ?? op.value;
}
function unset(op) {}
function inc(op, currentValue) {
    if (typeof currentValue != "number") throw new TypeError('Cannot apply "inc()" on non-numeric value');
    return currentValue + op.amount;
}
function dec(op, currentValue) {
    if (typeof currentValue != "number") throw new TypeError('Cannot apply "dec()" on non-numeric value');
    return currentValue - op.amount;
}
const hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
function isEmpty(v) {
    for(const key in v)if (hasOwn(v, key)) return !1;
    return !0;
}
function omit(val, props) {
    const copy = {
        ...val
    };
    for (const prop of props)delete copy[prop];
    return copy;
}
function unassign(op, currentValue) {
    if (!isObject(currentValue)) throw new TypeError('Cannot apply "unassign()" on non-object value');
    return op.keys.length === 0 ? currentValue : omit(currentValue, op.keys);
}
function assign(op, currentValue) {
    if (!isObject(currentValue)) throw new TypeError('Cannot apply "assign()" on non-object value');
    return isEmpty(op.value) ? currentValue : {
        ...currentValue,
        ...op.value
    };
}
function diffMatchPatch(op, currentValue) {
    if (typeof currentValue != "string") throw new TypeError('Cannot apply "diffMatchPatch()" on non-string value');
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyPatches"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parsePatch"])(op.value), currentValue)[0];
}
var operations = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    assign,
    dec,
    diffMatchPatch,
    inc,
    insert,
    remove,
    replace,
    set,
    setIfMissing,
    truncate,
    unassign,
    unset,
    upsert
});
function applyOp(op, currentValue) {
    if (!(op.type in operations)) throw new Error(`Invalid operation type: "${op.type}"`);
    return operations[op.type](op, currentValue);
}
function applyPatches(patches, document) {
    return patches.reduce((prev, patch2)=>applyNodePatch(patch2, prev), document);
}
function applyNodePatch(patch2, document) {
    return applyAtPath(patch2.path, patch2.op, document);
}
function applyAtPath(path, op, value) {
    if (!isNonEmptyArray(path)) return applyOp(op, value);
    const [head, ...tail] = path;
    if (isArrayElement(head) && Array.isArray(value)) return applyInArray(head, tail, op, value);
    if (isPropertyElement(head) && isObject(value)) return applyInObject(head, tail, op, value);
    throw new Error(`Cannot apply operation of type "${op.type}" to path ${stringify(path)} on ${typeof value} value`);
}
function applyInObject(head, tail, op, object) {
    const current = object[head];
    if (current === void 0 && tail.length > 0) return object;
    const patchedValue = applyAtPath(tail, op, current);
    return patchedValue === current ? object : {
        ...object,
        [head]: patchedValue
    };
}
function applyInArray(head, tail, op, value) {
    const index = findTargetIndex(value, head);
    if (index === null || index === -1) return value;
    const current = value[index], patchedItem = applyAtPath(tail, op, current);
    return patchedItem === current ? value : splice(value, index, 1, [
        patchedItem
    ]);
}
function isNonEmptyArray(a) {
    return a.length > 0;
}
function applyPatchMutation(mutation, document) {
    if (mutation.options?.ifRevision && document._rev !== mutation.options.ifRevision) throw new Error("Revision mismatch");
    if (mutation.id !== document._id) throw new Error(`Document id mismatch. Refusing to apply mutation for document with id="${mutation.id}" on the given document with id="${document._id}"`);
    return applyPatches(mutation.patches, document);
}
function hasId(doc) {
    return "_id" in doc;
}
function assignId(doc, generateId) {
    return hasId(doc) ? doc : {
        ...doc,
        _id: generateId()
    };
}
function applyAll(current, mutation) {
    return mutation.reduce((doc, m)=>{
        const res = applyDocumentMutation(doc, m);
        if (res.status === "error") throw new Error(res.message);
        return res.status === "noop" ? doc : res.after;
    }, current);
}
function applyDocumentMutation(document, mutation) {
    if (mutation.type === "create") return create(document, mutation);
    if (mutation.type === "createIfNotExists") return createIfNotExists(document, mutation);
    if (mutation.type === "delete") return del(document, mutation);
    if (mutation.type === "createOrReplace") return createOrReplace(document, mutation);
    if (mutation.type === "patch") return patch(document, mutation);
    throw new Error(`Invalid mutation type: ${mutation.type}`);
}
function create(document, mutation) {
    if (document) return {
        status: "error",
        message: "Document already exist"
    };
    const result = assignId(mutation.document, nanoid);
    return {
        status: "created",
        id: result._id,
        after: result
    };
}
function createIfNotExists(document, mutation) {
    return hasId(mutation.document) ? document ? {
        status: "noop"
    } : {
        status: "created",
        id: mutation.document._id,
        after: mutation.document
    } : {
        status: "error",
        message: "Cannot createIfNotExists on document without _id"
    };
}
function createOrReplace(document, mutation) {
    return hasId(mutation.document) ? document ? {
        status: "updated",
        id: mutation.document._id,
        before: document,
        after: mutation.document
    } : {
        status: "created",
        id: mutation.document._id,
        after: mutation.document
    } : {
        status: "error",
        message: "Cannot createIfNotExists on document without _id"
    };
}
function del(document, mutation) {
    return document ? mutation.id !== document._id ? {
        status: "error",
        message: "Delete mutation targeted wrong document"
    } : {
        status: "deleted",
        id: mutation.id,
        before: document,
        after: void 0
    } : {
        status: "noop"
    };
}
function patch(document, mutation) {
    if (!document) return {
        status: "error",
        message: "Cannot apply patch on nonexistent document"
    };
    const next = applyPatchMutation(mutation, document);
    return document === next ? {
        status: "noop"
    } : {
        status: "updated",
        id: mutation.id,
        before: document,
        after: next
    };
}
function applyMutations(mutations, dataset) {
    const updatedDocs = /* @__PURE__ */ Object.create(null);
    for (const mutation of mutations){
        const documentId = getMutationDocumentId(mutation);
        if (!documentId) throw new Error("Unable to get document id from mutation");
        const before = updatedDocs[documentId]?.after || dataset.get(documentId), res = applyDocumentMutation(before, mutation);
        if (res.status === "error") throw new Error(res.message);
        res.status !== "noop" && (res.status === "updated" || res.status === "created" || res.status === "deleted") && (documentId in updatedDocs || (updatedDocs[documentId] = {
            before,
            after: void 0,
            muts: []
        }), updatedDocs[documentId].after = res.after);
    }
    return Object.entries(updatedDocs).map(// eslint-disable-next-line no-shadow
    ([id, { before, after, muts }])=>({
            id,
            status: after ? before ? "updated" : "created" : "deleted",
            mutations: muts,
            before,
            after
        }));
}
function commit(results, dataset) {
    results.forEach((result)=>{
        (result.status === "created" || result.status === "updated") && dataset.set(result.id, result.after), result.status === "deleted" && dataset.delete(result.id);
    });
}
function takeUntilRight(arr, predicate, opts) {
    const result = [];
    for (const item of arr.slice().reverse()){
        if (predicate(item)) return result;
        result.push(item);
    }
    return result.reverse();
}
function isEqualPath(p1, p2) {
    return stringify(p1) === stringify(p2);
}
function supersedes(later, earlier) {
    return (earlier.type === "set" || earlier.type === "unset") && (later.type === "set" || later.type === "unset");
}
function squashNodePatches(patches) {
    return compactSetIfMissingPatches(compactSetPatches(compactUnsetPatches(patches)));
}
function compactUnsetPatches(patches) {
    return patches.reduce((earlierPatches, laterPatch)=>{
        if (laterPatch.op.type !== "unset") return earlierPatches.push(laterPatch), earlierPatches;
        const unaffected = earlierPatches.filter((earlierPatch)=>!startsWith(laterPatch.path, earlierPatch.path));
        return unaffected.push(laterPatch), unaffected;
    }, []);
}
function compactSetPatches(patches) {
    return patches.reduceRight((laterPatches, earlierPatch)=>(laterPatches.find((later)=>supersedes(later.op, earlierPatch.op) && isEqualPath(later.path, earlierPatch.path)) || laterPatches.unshift(earlierPatch), laterPatches), []);
}
function compactSetIfMissingPatches(patches) {
    return patches.reduce((previousPatches, laterPatch)=>laterPatch.op.type !== "setIfMissing" ? (previousPatches.push(laterPatch), previousPatches) : (takeUntilRight(previousPatches, (patch2)=>patch2.op.type === "unset").find((precedingPatch)=>precedingPatch.op.type === "setIfMissing" && isEqualPath(precedingPatch.path, laterPatch.path)) || previousPatches.push(laterPatch), previousPatches), []);
}
function compactDMPSetPatches(base, patches) {
    let edge = base;
    return patches.reduce((earlierPatches, laterPatch)=>{
        const before = edge;
        if (edge = applyNodePatch(laterPatch, edge), laterPatch.op.type === "set" && typeof laterPatch.op.value == "string") {
            const current = getAtPath(laterPatch.path, before);
            if (typeof current == "string") {
                const replaced = {
                    ...laterPatch,
                    op: {
                        type: "diffMatchPatch",
                        value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringifyPatches"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePatches"])(current, laterPatch.op.value))
                    }
                };
                return earlierPatches.flatMap((ep)=>isEqualPath(ep.path, laterPatch.path) && ep.op.type === "diffMatchPatch" ? [] : ep).concat(replaced);
            }
        }
        return earlierPatches.push(laterPatch), earlierPatches;
    }, []);
}
function squashDMPStrings(remote, mutationGroups) {
    return mutationGroups.map((mutationGroup)=>({
            ...mutationGroup,
            mutations: dmpIfyMutations(remote, mutationGroup.mutations)
        }));
}
function dmpIfyMutations(store, mutations) {
    return mutations.map((mutation, i)=>mutation.type === "patch" ? dmpifyPatchMutation(store.get(mutation.id), mutation) : mutation);
}
function dmpifyPatchMutation(base, mutation) {
    return base ? {
        ...mutation,
        patches: compactDMPSetPatches(base, mutation.patches)
    } : mutation;
}
function mergeMutationGroups(mutationGroups) {
    return chunkWhile(mutationGroups, (group)=>!group.transaction).flatMap((chunk)=>({
            ...chunk[0],
            mutations: chunk.flatMap((c)=>c.mutations)
        }));
}
function chunkWhile(arr, predicate) {
    const res = [];
    let currentChunk = [];
    return arr.forEach((item)=>{
        predicate(item) ? currentChunk.push(item) : (currentChunk.length > 0 && res.push(currentChunk), currentChunk = [], res.push([
            item
        ]));
    }), currentChunk.length > 0 && res.push(currentChunk), res;
}
function squashMutationGroups(staged) {
    return mergeMutationGroups(staged).map((transaction)=>({
            ...transaction,
            mutations: squashMutations(transaction.mutations)
        })).map((transaction)=>({
            ...transaction,
            mutations: transaction.mutations.map((mutation)=>mutation.type !== "patch" ? mutation : {
                    ...mutation,
                    patches: squashNodePatches(mutation.patches)
                })
        }));
}
function squashMutations(mutations) {
    const byDocument = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$groupBy$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__groupBy$3e$__["groupBy"])(mutations, getMutationDocumentId);
    return Object.values(byDocument).flatMap((documentMutations)=>squashCreateIfNotExists(squashDelete(documentMutations)).flat().reduce((acc, docMutation)=>{
            const prev = acc[acc.length - 1];
            return (!prev || prev.type === "patch") && docMutation.type === "patch" ? acc.slice(0, -1).concat({
                ...docMutation,
                patches: (prev?.patches || []).concat(docMutation.patches)
            }) : acc.concat(docMutation);
        }, []));
}
function squashCreateIfNotExists(mutations) {
    return mutations.length === 0 ? mutations : mutations.reduce((previousMuts, laterMut)=>laterMut.type !== "createIfNotExists" ? (previousMuts.push(laterMut), previousMuts) : (takeUntilRight(previousMuts, (m)=>m.type === "delete").find((precedingPatch)=>precedingPatch.type === "createIfNotExists") || previousMuts.push(laterMut), previousMuts), []);
}
function squashDelete(mutations) {
    return mutations.length === 0 ? mutations : mutations.reduce((previousMuts, laterMut)=>laterMut.type === "delete" ? [
            laterMut
        ] : (previousMuts.push(laterMut), previousMuts), []);
}
function rebase(documentId, oldBase, newBase, stagedMutations) {
    let edge = oldBase;
    const dmpified = stagedMutations.map((transaction)=>{
        const mutations = transaction.mutations.flatMap((mut)=>{
            if (getMutationDocumentId(mut) !== documentId) return [];
            const before = edge;
            return edge = applyAll(edge, [
                mut
            ]), !before || mut.type !== "patch" ? mut : {
                type: "dmpified",
                mutation: {
                    ...mut,
                    // Todo: make compactDMPSetPatches return pairs of patches that was dmpified with their
                    //  original as dmpPatches and original is not 1:1 (e..g some of the original may not be dmpified)
                    dmpPatches: compactDMPSetPatches(before, mut.patches),
                    original: mut.patches
                }
            };
        });
        return {
            ...transaction,
            mutations
        };
    });
    let newBaseWithDMPForOldBaseApplied = newBase;
    return dmpified.map((transaction)=>{
        const applied = [];
        return transaction.mutations.forEach((mut)=>{
            if (mut.type === "dmpified") try {
                newBaseWithDMPForOldBaseApplied = applyPatches(mut.mutation.dmpPatches, newBaseWithDMPForOldBaseApplied), applied.push(mut);
            } catch  {
                console.warn("Failed to apply dmp patch, falling back to original");
                try {
                    newBaseWithDMPForOldBaseApplied = applyPatches(mut.mutation.original, newBaseWithDMPForOldBaseApplied), applied.push(mut);
                } catch (second) {
                    throw new Error(`Failed to apply patch for document "${documentId}": ${second.message}`);
                }
            }
            else newBaseWithDMPForOldBaseApplied = applyAll(newBaseWithDMPForOldBaseApplied, [
                mut
            ]);
        });
    }), [
        stagedMutations.map((transaction)=>({
                ...transaction,
                mutations: transaction.mutations.map((mut)=>mut.type !== "patch" || getMutationDocumentId(mut) !== documentId ? mut : {
                        ...mut,
                        patches: mut.patches.map((patch2)=>patch2.op.type !== "set" ? patch2 : {
                                ...patch2,
                                op: {
                                    ...patch2.op,
                                    value: getAtPath(patch2.path, newBaseWithDMPForOldBaseApplied)
                                }
                            })
                    })
            })),
        newBaseWithDMPForOldBaseApplied
    ];
}
function toTransactions(groups) {
    return groups.map((group)=>group.transaction && group.id !== void 0 ? {
            id: group.id,
            mutations: group.mutations
        } : {
            mutations: group.mutations
        });
}
function encode(mutation) {
    return encodeMutation(mutation);
}
function encodeAll(mutations) {
    return mutations.flatMap(encode);
}
function encodeTransaction(transaction) {
    return {
        transactionId: transaction.id,
        mutations: encodeAll(transaction.mutations)
    };
}
function encodeMutation(mutation) {
    if (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") return {
        [mutation.type]: mutation.document
    };
    if (mutation.type === "delete") return {
        delete: {
            id: mutation.id
        }
    };
    const ifRevisionID = mutation.options?.ifRevision;
    return mutation.patches.map((patch2)=>({
            patch: {
                id: mutation.id,
                ...ifRevisionID && {
                    ifRevisionID
                },
                ...patchToSanity(patch2)
            }
        }));
}
function patchToSanity(patch2) {
    const { path, op } = patch2;
    if (op.type === "unset") return {
        unset: [
            stringify(path)
        ]
    };
    if (op.type === "insert") return {
        insert: {
            [op.position]: stringify([
                ...path,
                op.referenceItem
            ]),
            items: op.items
        }
    };
    if (op.type === "diffMatchPatch") return {
        diffMatchPatch: {
            [stringify(path)]: op.value
        }
    };
    if (op.type === "inc") return {
        inc: {
            [stringify(path)]: op.amount
        }
    };
    if (op.type === "dec") return {
        dec: {
            [stringify(path)]: op.amount
        }
    };
    if (op.type === "set" || op.type === "setIfMissing") return {
        [op.type]: {
            [stringify(path)]: op.value
        }
    };
    if (op.type === "truncate") {
        const range = [
            op.startIndex,
            typeof op.endIndex == "number" ? op.endIndex : ""
        ].join(":");
        return {
            unset: [
                `${stringify(path)}[${range}]`
            ]
        };
    }
    if (op.type === "upsert") return {
        unset: op.items.map((item)=>stringify([
                ...path,
                {
                    _key: item._key
                }
            ])),
        insert: {
            [op.position]: stringify([
                ...path,
                op.referenceItem
            ]),
            items: op.items
        }
    };
    if (op.type === "assign") return {
        set: Object.fromEntries(Object.keys(op.value).map((key)=>[
                stringify(path.concat(key)),
                op.value[key]
            ]))
    };
    if (op.type === "unassign") return {
        unset: op.keys.map((key)=>stringify(path.concat(key)))
    };
    if (op.type === "replace") return {
        insert: {
            replace: stringify(path.concat(op.referenceItem)),
            items: op.items
        }
    };
    if (op.type === "remove") return {
        unset: [
            stringify(path.concat(op.referenceItem))
        ]
    };
    throw new Error(`Unknown operation type ${op.type}`);
}
function createSharedListener(client) {
    const allEvents$ = client.listen('*[!(_id in path("_.**"))]', {}, {
        events: [
            "welcome",
            "mutation",
            "reconnect"
        ],
        includeResult: !1,
        includePreviousRevision: !1,
        visibility: "transaction",
        effectFormat: "mendoza",
        includeMutations: !1
    }).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$share$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["share"])({
        resetOnRefCountZero: !0
    })), reconnect = allEvents$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])((event)=>event.type === "reconnect")), welcome = allEvents$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])((event)=>event.type === "welcome")), mutations = allEvents$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])((event)=>event.type === "mutation")), replayWelcome = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])(welcome, reconnect).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$shareReplay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shareReplay"])({
        bufferSize: 1,
        refCount: !0
    })).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])((latestConnectionEvent)=>latestConnectionEvent.type === "welcome"));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])(replayWelcome, mutations, reconnect);
}
const documentMutatorMachine = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["setup"])({
    types: {},
    actions: {
        "assign error to context": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            error: ({ event })=>event
        }),
        "clear error from context": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            error: void 0
        }),
        "connect to server-sent events": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$1db27a82$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__O__as__raise$3e$__["raise"])({
            type: "connect"
        }),
        "listen to server-sent events": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$1db27a82$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__P__as__spawnChild$3e$__["spawnChild"])("server-sent events", {
            id: "listener",
            input: ({ context })=>({
                    listener: context.sharedListener || createSharedListener(context.client),
                    id: context.id
                })
        }),
        "stop listening to server-sent events": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$1db27a82$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__R__as__stopChild$3e$__["stopChild"])("listener"),
        "buffer remote mutation events": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            mutationEvents: ({ event, context })=>((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "mutation"), [
                    ...context.mutationEvents,
                    event
                ])
        }),
        "restore stashed changes": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            stagedChanges: ({ event, context })=>((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "xstate.done.actor.submitTransactions"), context.stashedChanges),
            stashedChanges: []
        }),
        "rebase fetched remote snapshot": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__b__as__enqueueActions$3e$__["enqueueActions"])(({ enqueue })=>{
            enqueue.assign(({ event, context })=>{
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "xstate.done.actor.getDocument");
                const previousRemote = context.remote;
                let nextRemote = event.output, seenCurrentRev = !1;
                for (const patch2 of context.mutationEvents)!patch2.effects?.apply || !patch2.previousRev && patch2.transition !== "appear" || (!seenCurrentRev && patch2.previousRev === nextRemote?._rev && (seenCurrentRev = !0), seenCurrentRev && (nextRemote = applyMendozaPatch(nextRemote, patch2.effects.apply, patch2.resultRev)));
                context.cache && // If the shared cache don't have the document already we can just set it
                (!context.cache.has(context.id) || // But when it's in the cache, make sure it's necessary to update it
                context.cache.get(context.id)._rev !== nextRemote?._rev) && context.cache.set(context.id, nextRemote);
                const [stagedChanges, local] = rebase(context.id, // It's annoying to convert between null and undefined, reach consensus
                previousRemote === null ? void 0 : previousRemote, nextRemote === null ? void 0 : nextRemote, context.stagedChanges);
                return {
                    remote: nextRemote,
                    local,
                    stagedChanges,
                    // Since the snapshot handler applies all the patches they are no longer needed, allow GC
                    mutationEvents: []
                };
            }), enqueue.sendParent(({ context })=>({
                    type: "rebased.remote",
                    id: context.id,
                    document: context.remote
                }));
        }),
        "apply mendoza patch": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])(({ event, context })=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "mutation");
            const previousRemote = context.remote;
            if (event.transactionId === previousRemote?._rev) return {};
            const nextRemote = applyMendozaPatch(previousRemote, event.effects.apply, event.resultRev);
            context.cache && // If the shared cache don't have the document already we can just set it
            (!context.cache.has(context.id) || // But when it's in the cache, make sure it's necessary to update it
            context.cache.get(context.id)._rev !== nextRemote?._rev) && context.cache.set(context.id, nextRemote);
            const [stagedChanges, local] = rebase(context.id, // It's annoying to convert between null and undefined, reach consensus
            previousRemote === null ? void 0 : previousRemote, nextRemote === null ? void 0 : nextRemote, context.stagedChanges);
            return {
                remote: nextRemote,
                local,
                stagedChanges
            };
        }),
        "increment fetch attempts": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            fetchRemoteSnapshotAttempts: ({ context })=>context.fetchRemoteSnapshotAttempts + 1
        }),
        "reset fetch attempts": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            fetchRemoteSnapshotAttempts: 0
        }),
        "increment submit attempts": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            submitTransactionsAttempts: ({ context })=>context.submitTransactionsAttempts + 1
        }),
        "reset submit attempts": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            submitTransactionsAttempts: 0
        }),
        "stage mutation": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            stagedChanges: ({ event, context })=>((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "mutate"), [
                    ...context.stagedChanges,
                    {
                        transaction: !1,
                        mutations: event.mutations
                    }
                ])
        }),
        "stash mutation": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            stashedChanges: ({ event, context })=>((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "mutate"), [
                    ...context.stashedChanges,
                    {
                        transaction: !1,
                        mutations: event.mutations
                    }
                ])
        }),
        "rebase local snapshot": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__b__as__enqueueActions$3e$__["enqueueActions"])(({ enqueue })=>{
            enqueue.assign({
                local: ({ event, context })=>{
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "mutate");
                    const localDataset = /* @__PURE__ */ new Map();
                    context.local && localDataset.set(context.id, context.local);
                    const results = applyMutations(event.mutations, localDataset);
                    return commit(results, localDataset), localDataset.get(context.id);
                }
            }), enqueue.sendParent(({ context })=>({
                    type: "rebased.local",
                    id: context.id,
                    document: context.local
                }));
        }),
        "send pristine event to parent": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__s__as__sendParent$3e$__["sendParent"])(({ context })=>({
                type: "pristine",
                id: context.id
            })),
        "send sync event to parent": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__s__as__sendParent$3e$__["sendParent"])(({ context })=>({
                type: "sync",
                id: context.id,
                document: context.remote
            })),
        "send mutation event to parent": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__s__as__sendParent$3e$__["sendParent"])(({ context, event })=>((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "mutation"), {
                type: "mutation",
                id: context.id,
                previousRev: event.previousRev,
                resultRev: event.resultRev,
                effects: event.effects
            }))
    },
    actors: {
        "server-sent events": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromEventObservable"])(({ input })=>{
            const { listener, id } = input;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$defer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defer"])(()=>listener).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])((event)=>event.type === "welcome" || event.type === "reconnect" || event.type === "mutation" && event.documentId === id), // This is necessary to avoid sync emitted events from `shareReplay` from happening before the actor is ready to receive them
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$observeOn$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["observeOn"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$asap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asapScheduler"]));
        }),
        "fetch remote snapshot": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromPromise"])(async ({ input, signal })=>{
            const { client, id } = input;
            return await client.getDocument(id, {
                signal
            }).catch((e)=>{
                if (!(e instanceof Error && e.name === "AbortError")) throw e;
            });
        }),
        "submit mutations as transactions": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromPromise"])(async ({ input, signal })=>{
            const { client, transactions } = input;
            for (const transaction of transactions){
                if (signal.aborted) return;
                await client.dataRequest("mutate", encodeTransaction(transaction), {
                    visibility: "async",
                    returnDocuments: !1,
                    signal
                }).catch((e)=>{
                    if (!(e instanceof Error && e.name === "AbortError")) throw e;
                });
            }
        })
    },
    delays: {
        // Exponential backoff delay function
        fetchRemoteSnapshotTimeout: ({ context })=>Math.pow(2, context.fetchRemoteSnapshotAttempts) * 1e3,
        submitTransactionsTimeout: ({ context })=>Math.pow(2, context.submitTransactionsAttempts) * 1e3
    }
}).createMachine({
    /** @xstate-layout N4IgpgJg5mDOIC5QQPYGMCuBbMA7ALgLRYb4CG+KATgMQnn5gDaADALqKgAOKsAlvj4pcnEAA9EADhYAWAHQA2GSwUBmAKwBOaQEZJkhQBoQAT0Q6ATAF8rx1JhwFipCtTkQ+sNMNxg0jCBpvXF9-Vg4kEB5+QWFRCQQLFhY5PQB2dRU1SQsdGSVjMwRlHTkWNM00nR1VKryKmzt0bDwielcqOWDQwVwoGgB3MAAbbxxw0WiBIRFIhPUKuQ1NVU0tTU0WFdVCxAt1dTlNhX2WdRltGUk061sQexandspO7r9e-qo-H3eJyKnYrNQPNJJollpVutNttdghVCo5MoTgoMpo8jIkqpGvdmo42i4Xl0fv4+H0aGAqFRqH9uLxpnE5ogFrCLFd5CtNBYFJkdOpuaosXcHnjnAw3G9-AAxMh8YYYL5BYn4GlROmA+KIFEs1R6ORpZYWHIXGR6bHC1qijpyL4Sj6DEZjZjsSZqmYaxK1ORcvlc-ZqSoyNKwnRpGTyK4WDK5BQ6BQ5BRm3EW55uG1K0n9ClUqgqgFuxketJe7nIv2rUNB0x7LmSL2qGMsSySevcmSJhzJgnipWQOgEma510M4HmcqHZYyWqaOMqTQyWGh0osVSGiwC5uGyftx74sWvHuBNMhX7O-5DoHiPae72lvnlwPBydFlRVS7qPIl7cilP74-+SByMMKBkB4ZKoL4cikgAbigADWYByDA+AACJJgQg4xPmI7FHkZQrKGsjqKcCiaMG9YpJOxySBiCiyPoX6dnuRJ-gEgHAaBmaUm4XDDBQABm1BYIhYAoWhyqnrSmHDpeCAKCicjUbU6g6nkFichYsJrLWVxaPsk7KdICZCmJlqEraAFASBvbPAOEmqlJF4JJURbVDcy4Yvk1GVkUsabApMjKZGqjNg2kgMU8Xa-j0FnsQBXBUJ4vRgH2DBOhEkn0o5TLKV6y6WDG6lhkYVYIDoKzyBkeR8pUDZqOFu5WuZEBsVZzUeFQ+AmDQsAYAARlgAgYZl7o6I2tYLJINSSO+3JaMGlQpGkhFhryo2jW2xkdhFTFNS1EAAT1-UCHa4EIdBcEIYdA34AAKlQZC4LAZAksIsBDeqBbrdpym8iuByxlcLK5BYqQLBUZyTcFvL1aZ3YsTFrVyFdx0ZuSXGdDx-GCUjfXXXdD1PS9j3vVhMnrWCFRxtNaRLdcfIsiwuS5fkgZaOUlhpDDP7MdFzWWftzXI-gdrPGlLoOSNyiHFstRySisjcgzahyFoUYBbRsac5tO6w1F7wIwLONHfg0qyvKyVfPgVAmCT0kJGt41pJD02xgcpElUkcZ6rI+q5JcckbU0W0NWZB57QduMCKbcoKmIsCpXIZB8YwVAABRC-jj3PYCsA3XwOAoKQACUNDmttjVh-zEfG9H5u21lpVjSrTtTTNbsstUYJJAFWgA37XORTz+t8+xtcKpb1v1+6KJFopGQqRi6nBlstYcqNK5riusYDztlejzKMfJXHCdJynqd8SJaAABYAEpgFgKCMAAyrgZBcLAV+P3nBfF6XJnc7tfmY8xZnglgWGe-klILzUhYDSJVRpnCONNOcWxWRKBRDYO4uAUD7XgJEMuIdqDi2GgWQgOhgxMyRKyFc8IuQkXUDvK0HgvAHmIR9bCD4SoeSWCoLkoZpxrmXIw0OLEMxsNJgkSc418KhnrHyG4oZYTcPhMifhJx4SCiDjrABSpgHiLtogAUhwW77DRIGXkk55wexKCrJQsg1jBTnPsYRqZviiL6PohuORgyhhBhGKMsZYzxhcXrf8EBPHulUJOPCtRlABWIu7IoORVBIIhMpNYGJyghKHmEvaYjQEkOwhkxQrJtBES0JDOBPlkgKD1JYZSjZORyTXNkwBsVwkFPYTJVYS58JxPKbOYM0gUj7FjGcEMOpciaJxMHXWOTWJV2avFRKpIwARILJRGJBF4mZBIkDE0KtIxLSSDkDYGhWl70Ru1Tq6zsLURBkoLyWRmz8PmlUZmcY1zXDKdMghcy2mIyFh8W5ZN4RFmOFyKaZwiLeT2GVJcy5pBrguCiMK2tvyDwBYbIWejOkSMQBkeQORJq0RNCUDIDNondxuGpPQmRqIXPhiPECuKMpdMkbILZ-SEnLxyjqOJMZsj1jRTYIAA */ id: "document-mutator",
    context: ({ input })=>({
            client: input.client.withConfig({
                allowReconfigure: !1
            }),
            sharedListener: input.sharedListener,
            id: input.id,
            remote: void 0,
            local: void 0,
            mutationEvents: [],
            stagedChanges: [],
            stashedChanges: [],
            error: void 0,
            fetchRemoteSnapshotAttempts: 0,
            submitTransactionsAttempts: 0,
            cache: input.cache
        }),
    // Auto start the connection by default
    entry: [
        "connect to server-sent events"
    ],
    on: {
        mutate: {
            actions: [
                "rebase local snapshot",
                "stage mutation"
            ]
        }
    },
    initial: "disconnected",
    states: {
        disconnected: {
            on: {
                connect: {
                    target: "connecting",
                    actions: [
                        "listen to server-sent events"
                    ]
                }
            }
        },
        connecting: {
            on: {
                welcome: "connected",
                reconnect: "reconnecting",
                error: "connectFailure"
            },
            tags: [
                "busy"
            ]
        },
        connectFailure: {
            on: {
                connect: {
                    target: "connecting",
                    actions: [
                        "listen to server-sent events"
                    ]
                }
            },
            entry: [
                "stop listening to server-sent events",
                "assign error to context"
            ],
            exit: [
                "clear error from context"
            ],
            tags: [
                "error"
            ]
        },
        reconnecting: {
            on: {
                welcome: {
                    target: "connected"
                },
                error: {
                    target: "connectFailure"
                }
            },
            tags: [
                "busy",
                "error"
            ]
        },
        connected: {
            on: {
                mutation: {
                    actions: [
                        "buffer remote mutation events"
                    ]
                },
                reconnect: "reconnecting"
            },
            entry: [
                "clear error from context"
            ],
            initial: "loading",
            states: {
                loading: {
                    invoke: {
                        src: "fetch remote snapshot",
                        id: "getDocument",
                        input: ({ context })=>({
                                client: context.client,
                                id: context.id
                            }),
                        onError: {
                            target: "loadFailure"
                        },
                        onDone: {
                            target: "loaded",
                            actions: [
                                "rebase fetched remote snapshot",
                                "reset fetch attempts"
                            ]
                        }
                    },
                    tags: [
                        "busy"
                    ]
                },
                loaded: {
                    entry: [
                        "send sync event to parent"
                    ],
                    on: {
                        mutation: {
                            actions: [
                                "apply mendoza patch",
                                "send mutation event to parent"
                            ]
                        }
                    },
                    initial: "pristine",
                    states: {
                        pristine: {
                            on: {
                                mutate: {
                                    actions: [
                                        "rebase local snapshot",
                                        "stage mutation"
                                    ],
                                    target: "dirty"
                                }
                            },
                            tags: [
                                "ready"
                            ]
                        },
                        dirty: {
                            on: {
                                submit: "submitting"
                            },
                            tags: [
                                "ready"
                            ]
                        },
                        submitting: {
                            on: {
                                mutate: {
                                    actions: [
                                        "rebase local snapshot",
                                        "stash mutation"
                                    ]
                                }
                            },
                            invoke: {
                                src: "submit mutations as transactions",
                                id: "submitTransactions",
                                input: ({ context })=>{
                                    const remoteDataset = /* @__PURE__ */ new Map();
                                    return remoteDataset.set(context.id, context.remote), {
                                        client: context.client,
                                        transactions: toTransactions(// Squashing DMP strings is the last thing we do before submitting
                                        squashDMPStrings(remoteDataset, squashMutationGroups(context.stagedChanges)))
                                    };
                                },
                                onError: {
                                    target: "submitFailure"
                                },
                                onDone: {
                                    target: "pristine",
                                    actions: [
                                        "restore stashed changes",
                                        "reset submit attempts",
                                        "send pristine event to parent"
                                    ]
                                }
                            },
                            /**
               * 'busy' means we should show a spinner, 'ready' means we can still accept mutations, they'll be applied optimistically right away, and queued for submissions after the current submission settles
               */ tags: [
                                "busy",
                                "ready"
                            ]
                        },
                        submitFailure: {
                            exit: [
                                "clear error from context"
                            ],
                            after: {
                                submitTransactionsTimeout: {
                                    actions: [
                                        "increment submit attempts"
                                    ],
                                    target: "submitting"
                                }
                            },
                            on: {
                                retry: "submitting"
                            },
                            /**
               * How can it be both `ready` and `error`? `ready` means it can receive mutations, optimistically apply them, and queue them for submission. `error` means it failed to submit previously applied mutations.
               * It's completely fine to keep queueing up more mutations and applying them optimistically, while showing UI that notifies that mutations didn't submit, and show a count down until the next automatic retry.
               */ tags: [
                                "error",
                                "ready"
                            ]
                        }
                    }
                },
                loadFailure: {
                    exit: [
                        "clear error from context"
                    ],
                    after: {
                        fetchRemoteSnapshotTimeout: {
                            actions: [
                                "increment fetch attempts"
                            ],
                            target: "loading"
                        }
                    },
                    on: {
                        retry: "loading"
                    },
                    tags: [
                        "error"
                    ]
                }
            }
        }
    }
});
function applyMendozaPatch(document, patch2, nextRevision) {
    const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mendoza$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyPatch"])(omitRev(document), patch2);
    return next ? Object.assign(next, {
        _rev: nextRevision
    }) : null;
}
function omitRev(document) {
    if (!document) return null;
    const { _rev, ...doc } = document;
    return doc;
}
;
 //# sourceMappingURL=_unstable_machine.browser.js.map
}}),
"[project]/node_modules/get-random-values-esm/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// Strict ESM env, designed to run outside Node.js in envs that provide WebCrypto (deno, browsers, etc)
__turbopack_esm__({
    "default": (()=>getRandomValues)
});
function getRandomValues(typedArray) {
    const crypto = typeof window !== 'undefined' && 'crypto' in window ? window.crypto : globalThis.crypto;
    if (!crypto || !crypto.getRandomValues) {
        throw new Error('WebCrypto not available in this environment');
    }
    return crypto.getRandomValues(typedArray);
}
}}),
"[project]/node_modules/use-effect-event/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "useEffectEvent": (()=>useEffectEvent)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
function useEffectEvent(fn) {
    const ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useInsertionEffect"])({
        "useEffectEvent.useInsertionEffect": ()=>{
            ref.current = fn;
        }
    }["useEffectEvent.useInsertionEffect"], [
        fn
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useEffectEvent.useCallback": (...args)=>{
            const latestFn = ref.current;
            return latestFn(...args);
        }
    }["useEffectEvent.useCallback"], []);
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/compute-scroll-into-view/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "compute": (()=>r)
});
const t = (t)=>"object" == typeof t && null != t && 1 === t.nodeType, e = (t, e)=>(!e || "hidden" !== t) && "visible" !== t && "clip" !== t, n = (t, n)=>{
    if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
        const o = getComputedStyle(t, null);
        return e(o.overflowY, n) || e(o.overflowX, n) || ((t)=>{
            const e = ((t)=>{
                if (!t.ownerDocument || !t.ownerDocument.defaultView) return null;
                try {
                    return t.ownerDocument.defaultView.frameElement;
                } catch (t) {
                    return null;
                }
            })(t);
            return !!e && (e.clientHeight < t.scrollHeight || e.clientWidth < t.scrollWidth);
        })(t);
    }
    return !1;
}, o = (t, e, n, o, l, r, i, s)=>r < t && i > e || r > t && i < e ? 0 : r <= t && s <= n || i >= e && s >= n ? r - t - o : i > e && s < n || r < t && s > n ? i - e + l : 0, l = (t)=>{
    const e = t.parentElement;
    return null == e ? t.getRootNode().host || null : e;
}, r = (e, r)=>{
    var i, s, d, h;
    if ("undefined" == typeof document) return [];
    const { scrollMode: c, block: f, inline: u, boundary: a, skipOverflowHiddenElements: g } = r, p = "function" == typeof a ? a : (t)=>t !== a;
    if (!t(e)) throw new TypeError("Invalid target");
    const m = document.scrollingElement || document.documentElement, w = [];
    let W = e;
    for(; t(W) && p(W);){
        if (W = l(W), W === m) {
            w.push(W);
            break;
        }
        null != W && W === document.body && n(W) && !n(document.documentElement) || null != W && n(W, g) && w.push(W);
    }
    const b = null != (s = null == (i = window.visualViewport) ? void 0 : i.width) ? s : innerWidth, H = null != (h = null == (d = window.visualViewport) ? void 0 : d.height) ? h : innerHeight, { scrollX: y, scrollY: M } = window, { height: v, width: E, top: x, right: C, bottom: I, left: R } = e.getBoundingClientRect(), { top: T, right: B, bottom: F, left: V } = ((t)=>{
        const e = window.getComputedStyle(t);
        return {
            top: parseFloat(e.scrollMarginTop) || 0,
            right: parseFloat(e.scrollMarginRight) || 0,
            bottom: parseFloat(e.scrollMarginBottom) || 0,
            left: parseFloat(e.scrollMarginLeft) || 0
        };
    })(e);
    let k = "start" === f || "nearest" === f ? x - T : "end" === f ? I + F : x + v / 2 - T + F, D = "center" === u ? R + E / 2 - V + B : "end" === u ? C + B : R - V;
    const L = [];
    for(let t = 0; t < w.length; t++){
        const e = w[t], { height: n, width: l, top: r, right: i, bottom: s, left: d } = e.getBoundingClientRect();
        if ("if-needed" === c && x >= 0 && R >= 0 && I <= H && C <= b && x >= r && I <= s && R >= d && C <= i) return L;
        const h = getComputedStyle(e), a = parseInt(h.borderLeftWidth, 10), g = parseInt(h.borderTopWidth, 10), p = parseInt(h.borderRightWidth, 10), W = parseInt(h.borderBottomWidth, 10);
        let T = 0, B = 0;
        const F = "offsetWidth" in e ? e.offsetWidth - e.clientWidth - a - p : 0, V = "offsetHeight" in e ? e.offsetHeight - e.clientHeight - g - W : 0, S = "offsetWidth" in e ? 0 === e.offsetWidth ? 0 : l / e.offsetWidth : 0, X = "offsetHeight" in e ? 0 === e.offsetHeight ? 0 : n / e.offsetHeight : 0;
        if (m === e) T = "start" === f ? k : "end" === f ? k - H : "nearest" === f ? o(M, M + H, H, g, W, M + k, M + k + v, v) : k - H / 2, B = "start" === u ? D : "center" === u ? D - b / 2 : "end" === u ? D - b : o(y, y + b, b, a, p, y + D, y + D + E, E), T = Math.max(0, T + M), B = Math.max(0, B + y);
        else {
            T = "start" === f ? k - r - g : "end" === f ? k - s + W + V : "nearest" === f ? o(r, s, n, g, W + V, k, k + v, v) : k - (r + n / 2) + V / 2, B = "start" === u ? D - d - a : "center" === u ? D - (d + l / 2) + F / 2 : "end" === u ? D - i + p + F : o(d, i, l, a, p + F, D, D + E, E);
            const { scrollLeft: t, scrollTop: h } = e;
            T = 0 === X ? 0 : Math.max(0, Math.min(h + T / X, e.scrollHeight - n / X + V)), B = 0 === S ? 0 : Math.max(0, Math.min(t + B / S, e.scrollWidth - l / S + F)), k += h - T, D += t - B;
        }
        L.push({
            el: e,
            top: T,
            left: B
        });
    }
    return L;
};
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/scroll-into-view-if-needed/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>e)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$compute$2d$scroll$2d$into$2d$view$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/compute-scroll-into-view/dist/index.js [app-client] (ecmascript)");
;
const o = (t)=>!1 === t ? {
        block: "end",
        inline: "nearest"
    } : ((t)=>t === Object(t) && 0 !== Object.keys(t).length)(t) ? t : {
        block: "start",
        inline: "nearest"
    };
function e(e, r) {
    if (!e.isConnected || !((t)=>{
        let o = t;
        for(; o && o.parentNode;){
            if (o.parentNode === document) return !0;
            o = o.parentNode instanceof ShadowRoot ? o.parentNode.host : o.parentNode;
        }
        return !1;
    })(e)) return;
    const n = ((t)=>{
        const o = window.getComputedStyle(t);
        return {
            top: parseFloat(o.scrollMarginTop) || 0,
            right: parseFloat(o.scrollMarginRight) || 0,
            bottom: parseFloat(o.scrollMarginBottom) || 0,
            left: parseFloat(o.scrollMarginLeft) || 0
        };
    })(e);
    if (((t)=>"object" == typeof t && "function" == typeof t.behavior)(r)) return r.behavior((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$compute$2d$scroll$2d$into$2d$view$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compute"])(e, r));
    const l = "boolean" == typeof r || null == r ? void 0 : r.behavior;
    for (const { el: a, top: i, left: s } of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$compute$2d$scroll$2d$into$2d$view$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compute"])(e, o(r))){
        const t = i - n.top + n.bottom, o = s - n.left + n.right;
        a.scroll({
            top: t,
            left: o,
            behavior: l
        });
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@vercel/stega/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "VERCEL_STEGA_REGEX": (()=>f),
    "legacyStegaEncode": (()=>y),
    "vercelStegaClean": (()=>O),
    "vercelStegaCombine": (()=>C),
    "vercelStegaDecode": (()=>G),
    "vercelStegaDecodeAll": (()=>$),
    "vercelStegaEncode": (()=>E),
    "vercelStegaSplit": (()=>_)
});
var s = {
    0: 8203,
    1: 8204,
    2: 8205,
    3: 8290,
    4: 8291,
    5: 8288,
    6: 65279,
    7: 8289,
    8: 119155,
    9: 119156,
    a: 119157,
    b: 119158,
    c: 119159,
    d: 119160,
    e: 119161,
    f: 119162
}, c = {
    0: 8203,
    1: 8204,
    2: 8205,
    3: 65279
}, u = new Array(4).fill(String.fromCodePoint(c[0])).join(""), m = String.fromCharCode(0);
function E(t) {
    let e = JSON.stringify(t);
    return `${u}${Array.from(e).map((r)=>{
        let n = r.charCodeAt(0);
        if (n > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);
        return Array.from(n.toString(4).padStart(4, "0")).map((o)=>String.fromCodePoint(c[o])).join("");
    }).join("")}`;
}
function y(t) {
    let e = JSON.stringify(t);
    return Array.from(e).map((r)=>{
        let n = r.charCodeAt(0);
        if (n > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);
        return Array.from(n.toString(16).padStart(2, "0")).map((o)=>String.fromCodePoint(s[o])).join("");
    }).join("");
}
function I(t) {
    return !Number.isNaN(Number(t)) || /[a-z]/i.test(t) && !/\d+(?:[-:\/]\d+){2}(?:T\d+(?:[-:\/]\d+){1,2}(\.\d+)?Z?)?/.test(t) ? !1 : Boolean(Date.parse(t));
}
function T(t) {
    try {
        new URL(t, t.startsWith("/") ? "https://acme.com" : void 0);
    } catch  {
        return !1;
    }
    return !0;
}
function C(t, e, r = "auto") {
    return r === !0 || r === "auto" && (I(t) || T(t)) ? t : `${t}${E(e)}`;
}
var x = Object.fromEntries(Object.entries(c).map((t)=>t.reverse())), g = Object.fromEntries(Object.entries(s).map((t)=>t.reverse())), S = `${Object.values(s).map((t)=>`\\u{${t.toString(16)}}`).join("")}`, f = new RegExp(`[${S}]{4,}`, "gu");
function G(t) {
    let e = t.match(f);
    if (!!e) return h(e[0], !0)[0];
}
function $(t) {
    let e = t.match(f);
    if (!!e) return e.map((r)=>h(r)).flat();
}
function h(t, e = !1) {
    let r = Array.from(t);
    if (r.length % 2 === 0) {
        if (r.length % 4 || !t.startsWith(u)) return A(r, e);
    } else throw new Error("Encoded data has invalid length");
    let n = [];
    for(let o = r.length * .25; o--;){
        let p = r.slice(o * 4, o * 4 + 4).map((d)=>x[d.codePointAt(0)]).join("");
        n.unshift(String.fromCharCode(parseInt(p, 4)));
    }
    if (e) {
        n.shift();
        let o = n.indexOf(m);
        return o === -1 && (o = n.length), [
            JSON.parse(n.slice(0, o).join(""))
        ];
    }
    return n.join("").split(m).filter(Boolean).map((o)=>JSON.parse(o));
}
function A(t, e) {
    var d;
    let r = [];
    for(let i = t.length * .5; i--;){
        let a = `${g[t[i * 2].codePointAt(0)]}${g[t[i * 2 + 1].codePointAt(0)]}`;
        r.unshift(String.fromCharCode(parseInt(a, 16)));
    }
    let n = [], o = [
        r.join("")
    ], p = 10;
    for(; o.length;){
        let i = o.shift();
        try {
            if (n.push(JSON.parse(i)), e) return n;
        } catch (a) {
            if (!p--) throw a;
            let l = +((d = a.message.match(/\sposition\s(\d+)$/)) == null ? void 0 : d[1]);
            if (!l) throw a;
            o.unshift(i.substring(0, l), i.substring(l));
        }
    }
    return n;
}
function _(t) {
    var e;
    return {
        cleaned: t.replace(f, ""),
        encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || ""
    };
}
function O(t) {
    return t && JSON.parse(_(JSON.stringify(t)).cleaned);
}
;
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "dateTimestampProvider": (()=>dateTimestampProvider)
});
var dateTimestampProvider = {
    now: function() {
        return (dateTimestampProvider.delegate || Date).now();
    },
    delegate: undefined
}; //# sourceMappingURL=dateTimestampProvider.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ObjectUnsubscribedError": (()=>ObjectUnsubscribedError)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$createErrorClass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js [app-client] (ecmascript)");
;
var ObjectUnsubscribedError = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$createErrorClass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createErrorClass"])(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = 'ObjectUnsubscribedError';
        this.message = 'object unsubscribed';
    };
}); //# sourceMappingURL=ObjectUnsubscribedError.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/Subject.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "AnonymousSubject": (()=>AnonymousSubject),
    "Subject": (()=>Subject)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$ObjectUnsubscribedError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$errorContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/util/errorContext.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subscription$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/Subscription.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$arrRemove$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/util/arrRemove.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/Observable.js [app-client] (ecmascript)");
;
;
;
;
;
;
var Subject = function(_super) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__extends"])(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype._throwIfClosed = function() {
        if (this.closed) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$ObjectUnsubscribedError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ObjectUnsubscribedError"]();
        }
    };
    Subject.prototype.next = function(value) {
        var _this = this;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$errorContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["errorContext"])(function() {
            var e_1, _a;
            _this._throwIfClosed();
            if (!_this.isStopped) {
                if (!_this.currentObservers) {
                    _this.currentObservers = Array.from(_this.observers);
                }
                try {
                    for(var _b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__values"])(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()){
                        var observer = _c.value;
                        observer.next(value);
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally{
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    } finally{
                        if (e_1) throw e_1.error;
                    }
                }
            }
        });
    };
    Subject.prototype.error = function(err) {
        var _this = this;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$errorContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["errorContext"])(function() {
            _this._throwIfClosed();
            if (!_this.isStopped) {
                _this.hasError = _this.isStopped = true;
                _this.thrownError = err;
                var observers = _this.observers;
                while(observers.length){
                    observers.shift().error(err);
                }
            }
        });
    };
    Subject.prototype.complete = function() {
        var _this = this;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$errorContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["errorContext"])(function() {
            _this._throwIfClosed();
            if (!_this.isStopped) {
                _this.isStopped = true;
                var observers = _this.observers;
                while(observers.length){
                    observers.shift().complete();
                }
            }
        });
    };
    Subject.prototype.unsubscribe = function() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject.prototype, "observed", {
        get: function() {
            var _a;
            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
    });
    Subject.prototype._trySubscribe = function(subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
    };
    Subject.prototype._innerSubscribe = function(subscriber) {
        var _this = this;
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        if (hasError || isStopped) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subscription$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY_SUBSCRIPTION"];
        }
        this.currentObservers = null;
        observers.push(subscriber);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subscription$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Subscription"](function() {
            _this.currentObservers = null;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$arrRemove$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrRemove"])(observers, subscriber);
        });
    };
    Subject.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) {
            subscriber.error(thrownError);
        } else if (isStopped) {
            subscriber.complete();
        }
    };
    Subject.prototype.asObservable = function() {
        var observable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observable"]();
        observable.source = this;
        return observable;
    };
    Subject.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observable"]);
;
var AnonymousSubject = function(_super) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__extends"])(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function(value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject.prototype.error = function(err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject.prototype.complete = function() {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject.prototype._subscribe = function(subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subscription$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY_SUBSCRIPTION"];
    };
    return AnonymousSubject;
}(Subject);
;
 //# sourceMappingURL=Subject.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ReplaySubject": (()=>ReplaySubject)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$dateTimestampProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/Subject.js [app-client] (ecmascript)");
;
;
;
var ReplaySubject = function(_super) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__extends"])(ReplaySubject, _super);
    function ReplaySubject(_bufferSize, _windowTime, _timestampProvider) {
        if (_bufferSize === void 0) {
            _bufferSize = Infinity;
        }
        if (_windowTime === void 0) {
            _windowTime = Infinity;
        }
        if (_timestampProvider === void 0) {
            _timestampProvider = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$dateTimestampProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dateTimestampProvider"];
        }
        var _this = _super.call(this) || this;
        _this._bufferSize = _bufferSize;
        _this._windowTime = _windowTime;
        _this._timestampProvider = _timestampProvider;
        _this._buffer = [];
        _this._infiniteTimeWindow = true;
        _this._infiniteTimeWindow = _windowTime === Infinity;
        _this._bufferSize = Math.max(1, _bufferSize);
        _this._windowTime = Math.max(1, _windowTime);
        return _this;
    }
    ReplaySubject.prototype.next = function(value) {
        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
        if (!isStopped) {
            _buffer.push(value);
            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        var subscription = this._innerSubscribe(subscriber);
        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
        var copy = _buffer.slice();
        for(var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2){
            subscriber.next(copy[i]);
        }
        this._checkFinalizedStatuses(subscriber);
        return subscription;
    };
    ReplaySubject.prototype._trimBuffer = function() {
        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
            var now = _timestampProvider.now();
            var last = 0;
            for(var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2){
                last = i;
            }
            last && _buffer.splice(0, last + 1);
        }
    };
    return ReplaySubject;
}(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Subject"]);
;
 //# sourceMappingURL=ReplaySubject.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "mergeAll": (()=>mergeAll)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/util/identity.js [app-client] (ecmascript)");
;
;
function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Infinity;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeMap"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identity"], concurrent);
} //# sourceMappingURL=mergeAll.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/observable/merge.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "merge": (()=>merge)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$args$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/util/args.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeAll$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/observable/from.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$innerFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/observable/empty.js [app-client] (ecmascript)");
;
;
;
;
;
function merge() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++){
        args[_i] = arguments[_i];
    }
    var scheduler = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$args$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["popScheduler"])(args);
    var concurrent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$args$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["popNumber"])(args, Infinity);
    var sources = args;
    return !sources.length ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY"] : sources.length === 1 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$innerFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["innerFrom"])(sources[0]) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeAll$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeAll"])(concurrent)((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])(sources, scheduler));
} //# sourceMappingURL=merge.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/operators/share.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "share": (()=>share)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/Subject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$lift$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/util/lift.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subscriber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/Subscriber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$innerFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
;
;
;
;
;
function share(options) {
    if (options === void 0) {
        options = {};
    }
    var _a = options.connector, connector = _a === void 0 ? function() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Subject"]();
    } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
    return function(wrapperSource) {
        var connection;
        var resetConnection;
        var subject;
        var refCount = 0;
        var hasCompleted = false;
        var hasErrored = false;
        var cancelReset = function() {
            resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
            resetConnection = undefined;
        };
        var reset = function() {
            cancelReset();
            connection = subject = undefined;
            hasCompleted = hasErrored = false;
        };
        var resetAndUnsubscribe = function() {
            var conn = connection;
            reset();
            conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
        };
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$lift$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["operate"])(function(source, subscriber) {
            refCount++;
            if (!hasErrored && !hasCompleted) {
                cancelReset();
            }
            var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
            subscriber.add(function() {
                refCount--;
                if (refCount === 0 && !hasErrored && !hasCompleted) {
                    resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
                }
            });
            dest.subscribe(subscriber);
            if (!connection && refCount > 0) {
                connection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subscriber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SafeSubscriber"]({
                    next: function(value) {
                        return dest.next(value);
                    },
                    error: function(err) {
                        hasErrored = true;
                        cancelReset();
                        resetConnection = handleReset(reset, resetOnError, err);
                        dest.error(err);
                    },
                    complete: function() {
                        hasCompleted = true;
                        cancelReset();
                        resetConnection = handleReset(reset, resetOnComplete);
                        dest.complete();
                    }
                });
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$innerFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["innerFrom"])(source).subscribe(connection);
            }
        })(wrapperSource);
    };
}
function handleReset(reset, on) {
    var args = [];
    for(var _i = 2; _i < arguments.length; _i++){
        args[_i - 2] = arguments[_i];
    }
    if (on === true) {
        reset();
        return;
    }
    if (on === false) {
        return;
    }
    var onSubscriber = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subscriber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SafeSubscriber"]({
        next: function() {
            onSubscriber.unsubscribe();
            reset();
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$innerFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["innerFrom"])(on.apply(void 0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__spreadArray"])([], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__read"])(args)))).subscribe(onSubscriber);
} //# sourceMappingURL=share.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "shareReplay": (()=>shareReplay)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$share$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/operators/share.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$ReplaySubject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js [app-client] (ecmascript)");
;
;
function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var _a, _b, _c;
    var bufferSize;
    var refCount = false;
    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
        _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
    } else {
        bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$share$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["share"])({
        connector: function() {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$ReplaySubject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ReplaySubject"](bufferSize, windowTime, scheduler);
        },
        resetOnError: true,
        resetOnComplete: false,
        resetOnRefCountZero: refCount
    });
} //# sourceMappingURL=shareReplay.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/Scheduler.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Scheduler": (()=>Scheduler)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$dateTimestampProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js [app-client] (ecmascript)");
;
var Scheduler = function() {
    function Scheduler(schedulerActionCtor, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
    }
    Scheduler.prototype.schedule = function(work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.schedulerActionCtor(this, work).schedule(state, delay);
    };
    Scheduler.now = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$dateTimestampProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dateTimestampProvider"].now;
    return Scheduler;
}();
;
 //# sourceMappingURL=Scheduler.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "AsyncScheduler": (()=>AsyncScheduler)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Scheduler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/Scheduler.js [app-client] (ecmascript)");
;
;
var AsyncScheduler = function(_super) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__extends"])(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Scheduler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scheduler"].now;
        }
        var _this = _super.call(this, SchedulerAction, now) || this;
        _this.actions = [];
        _this._active = false;
        return _this;
    }
    AsyncScheduler.prototype.flush = function(action) {
        var actions = this.actions;
        if (this._active) {
            actions.push(action);
            return;
        }
        var error;
        this._active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }while (action = actions.shift())
        this._active = false;
        if (error) {
            while(action = actions.shift()){
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Scheduler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scheduler"]);
;
 //# sourceMappingURL=AsyncScheduler.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "AsapScheduler": (()=>AsapScheduler)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$AsyncScheduler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js [app-client] (ecmascript)");
;
;
var AsapScheduler = function(_super) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__extends"])(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = undefined;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }while ((action = actions[0]) && action.id === flushId && actions.shift())
        this._active = false;
        if (error) {
            while((action = actions[0]) && action.id === flushId && actions.shift()){
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$AsyncScheduler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsyncScheduler"]);
;
 //# sourceMappingURL=AsapScheduler.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/util/Immediate.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Immediate": (()=>Immediate),
    "TestTools": (()=>TestTools)
});
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
    if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
    }
    return false;
}
var Immediate = {
    setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        if (!resolved) {
            resolved = Promise.resolve();
        }
        resolved.then(function() {
            return findAndClearHandle(handle) && cb();
        });
        return handle;
    },
    clearImmediate: function(handle) {
        findAndClearHandle(handle);
    }
};
var TestTools = {
    pending: function() {
        return Object.keys(activeHandles).length;
    }
}; //# sourceMappingURL=Immediate.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "immediateProvider": (()=>immediateProvider)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$Immediate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/util/Immediate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
;
;
var setImmediate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$Immediate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Immediate"].setImmediate, clearImmediate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$Immediate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Immediate"].clearImmediate;
var immediateProvider = {
    setImmediate: function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        var delegate = immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__spreadArray"])([], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__read"])(args)));
    },
    clearImmediate: function(handle) {
        var delegate = immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
    },
    delegate: undefined
}; //# sourceMappingURL=immediateProvider.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "intervalProvider": (()=>intervalProvider)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
;
var intervalProvider = {
    setInterval: function(handler, timeout) {
        var args = [];
        for(var _i = 2; _i < arguments.length; _i++){
            args[_i - 2] = arguments[_i];
        }
        var delegate = intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
            return delegate.setInterval.apply(delegate, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__spreadArray"])([
                handler,
                timeout
            ], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__read"])(args)));
        }
        return setInterval.apply(void 0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__spreadArray"])([
            handler,
            timeout
        ], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__read"])(args)));
    },
    clearInterval: function(handle) {
        var delegate = intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: undefined
}; //# sourceMappingURL=intervalProvider.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/scheduler/Action.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Action": (()=>Action)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subscription$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/Subscription.js [app-client] (ecmascript)");
;
;
var Action = function(_super) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__extends"])(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subscription$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Subscription"]);
;
 //# sourceMappingURL=Action.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "AsyncAction": (()=>AsyncAction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$intervalProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$arrRemove$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/util/arrRemove.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$Action$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/scheduler/Action.js [app-client] (ecmascript)");
;
;
;
;
var AsyncAction = function(_super) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__extends"])(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function(state, delay) {
        var _a;
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function(scheduler, _id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$intervalProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intervalProvider"].setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function(_scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay != null && this.delay === delay && this.pending === false) {
            return id;
        }
        if (id != null) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$intervalProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intervalProvider"].clearInterval(id);
        }
        return undefined;
    };
    AsyncAction.prototype.execute = function(state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        } else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function(state, _delay) {
        var errored = false;
        var errorValue;
        try {
            this.work(state);
        } catch (e) {
            errored = true;
            errorValue = e ? e : new Error('Scheduled action threw falsy error');
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype.unsubscribe = function() {
        if (!this.closed) {
            var _a = this, id = _a.id, scheduler = _a.scheduler;
            var actions = scheduler.actions;
            this.work = this.state = this.scheduler = null;
            this.pending = false;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$arrRemove$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrRemove"])(actions, this);
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, null);
            }
            this.delay = null;
            _super.prototype.unsubscribe.call(this);
        }
    };
    return AsyncAction;
}(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$Action$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Action"]);
;
 //# sourceMappingURL=AsyncAction.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "AsapAction": (()=>AsapAction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$immediateProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$AsyncAction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js [app-client] (ecmascript)");
;
;
;
var AsapAction = function(_super) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__extends"])(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$immediateProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["immediateProvider"].setImmediate(scheduler.flush.bind(scheduler, undefined)));
    };
    AsapAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
        var _a;
        if (delay === void 0) {
            delay = 0;
        }
        if (delay != null ? delay > 0 : this.delay > 0) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        var actions = scheduler.actions;
        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$immediateProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["immediateProvider"].clearImmediate(id);
            if (scheduler._scheduled === id) {
                scheduler._scheduled = undefined;
            }
        }
        return undefined;
    };
    return AsapAction;
}(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$AsyncAction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsyncAction"]);
;
 //# sourceMappingURL=AsapAction.js.map
}}),
"[project]/node_modules/rxjs/dist/esm5/internal/scheduler/asap.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "asap": (()=>asap),
    "asapScheduler": (()=>asapScheduler)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$AsapScheduler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$AsapAction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js [app-client] (ecmascript)");
;
;
var asapScheduler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$AsapScheduler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsapScheduler"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$scheduler$2f$AsapAction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsapAction"]);
var asap = asapScheduler; //# sourceMappingURL=asap.js.map
}}),
"[project]/node_modules/@sanity/diff-match-patch/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "DIFF_DELETE": (()=>DIFF_DELETE),
    "DIFF_EQUAL": (()=>DIFF_EQUAL),
    "DIFF_INSERT": (()=>DIFF_INSERT),
    "adjustIndiciesToUcs2": (()=>adjustIndiciesToUcs2),
    "applyPatches": (()=>apply),
    "cleanupEfficiency": (()=>cleanupEfficiency),
    "cleanupSemantic": (()=>cleanupSemantic),
    "makeDiff": (()=>diff),
    "makePatches": (()=>make),
    "match": (()=>match),
    "parsePatch": (()=>parse),
    "stringifyPatch": (()=>stringifyPatch),
    "stringifyPatches": (()=>stringify)
});
function cloneDiff(diff2) {
    const [type, patch] = diff2;
    return [
        type,
        patch
    ];
}
function getCommonOverlap(textA, textB) {
    let text1 = textA, text2 = textB;
    const text1Length = text1.length, text2Length = text2.length;
    if (text1Length === 0 || text2Length === 0) return 0;
    text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));
    const textLength = Math.min(text1Length, text2Length);
    if (text1 === text2) return textLength;
    let best = 0, length = 1;
    for(let found = 0; found !== -1;){
        const pattern = text1.substring(textLength - length);
        if (found = text2.indexOf(pattern), found === -1) return best;
        length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);
    }
    return best;
}
function getCommonPrefix(text1, text2) {
    if (!text1 || !text2 || text1[0] !== text2[0]) return 0;
    let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;
    for(; pointerMin < pointerMid;)text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
    return pointerMid;
}
function getCommonSuffix(text1, text2) {
    if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1]) return 0;
    let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;
    for(; pointerMin < pointerMid;)text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
    return pointerMid;
}
function isHighSurrogate(char) {
    const charCode = char.charCodeAt(0);
    return charCode >= 55296 && charCode <= 56319;
}
function isLowSurrogate(char) {
    const charCode = char.charCodeAt(0);
    return charCode >= 56320 && charCode <= 57343;
}
function bisect(text1, text2, deadline) {
    const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);
    for(let x = 0; x < vLength; x++)v1[x] = -1, v2[x] = -1;
    v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;
    const delta = text1Length - text2Length, front = delta % 2 !== 0;
    let k1start = 0, k1end = 0, k2start = 0, k2end = 0;
    for(let d = 0; d < maxD && !(Date.now() > deadline); d++){
        for(let k1 = -d + k1start; k1 <= d - k1end; k1 += 2){
            const k1Offset = vOffset + k1;
            let x1;
            k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;
            let y1 = x1 - k1;
            for(; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1);)x1++, y1++;
            if (v1[k1Offset] = x1, x1 > text1Length) k1end += 2;
            else if (y1 > text2Length) k1start += 2;
            else if (front) {
                const k2Offset = vOffset + delta - k1;
                if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {
                    const x2 = text1Length - v2[k2Offset];
                    if (x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);
                }
            }
        }
        for(let k2 = -d + k2start; k2 <= d - k2end; k2 += 2){
            const k2Offset = vOffset + k2;
            let x2;
            k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;
            let y2 = x2 - k2;
            for(; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1);)x2++, y2++;
            if (v2[k2Offset] = x2, x2 > text1Length) k2end += 2;
            else if (y2 > text2Length) k2start += 2;
            else if (!front) {
                const k1Offset = vOffset + delta - k2;
                if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
                    const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;
                    if (x2 = text1Length - x2, x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);
                }
            }
        }
    }
    return [
        [
            DIFF_DELETE,
            text1
        ],
        [
            DIFF_INSERT,
            text2
        ]
    ];
}
function bisectSplit(text1, text2, x, y, deadline) {
    const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, {
        checkLines: !1,
        deadline
    }), diffsb = doDiff(text1b, text2b, {
        checkLines: !1,
        deadline
    });
    return diffs.concat(diffsb);
}
function findHalfMatch(text1, text2, timeout = 1) {
    if (timeout <= 0) return null;
    const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;
    if (longText.length < 4 || shortText.length * 2 < longText.length) return null;
    const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));
    let halfMatch;
    if (halfMatch1 && halfMatch2) halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;
    else {
        if (!halfMatch1 && !halfMatch2) return null;
        halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;
    }
    if (!halfMatch) throw new Error("Unable to find a half match.");
    let text1A, text1B, text2A, text2B;
    text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);
    const midCommon = halfMatch[4];
    return [
        text1A,
        text1B,
        text2A,
        text2B,
        midCommon
    ];
}
function halfMatchI(longText, shortText, i) {
    const seed = longText.slice(i, i + Math.floor(longText.length / 4));
    let j = -1, bestCommon = "", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;
    for(; (j = shortText.indexOf(seed, j + 1)) !== -1;){
        const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));
        bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));
    }
    return bestCommon.length * 2 >= longText.length ? [
        bestLongTextA || "",
        bestLongTextB || "",
        bestShortTextA || "",
        bestShortTextB || "",
        bestCommon || ""
    ] : null;
}
function charsToLines(diffs, lineArray) {
    for(let x = 0; x < diffs.length; x++){
        const chars = diffs[x][1], text = [];
        for(let y = 0; y < chars.length; y++)text[y] = lineArray[chars.charCodeAt(y)];
        diffs[x][1] = text.join("");
    }
}
function linesToChars(textA, textB) {
    const lineArray = [], lineHash = {};
    lineArray[0] = "";
    function diffLinesToMunge(text) {
        let chars = "", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;
        for(; lineEnd < text.length - 1;){
            lineEnd = text.indexOf(`
`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);
            let line = text.slice(lineStart, lineEnd + 1);
            (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;
        }
        return chars;
    }
    let maxLines = 4e4;
    const chars1 = diffLinesToMunge(textA);
    maxLines = 65535;
    const chars2 = diffLinesToMunge(textB);
    return {
        chars1,
        chars2,
        lineArray
    };
}
function doLineModeDiff(textA, textB, opts) {
    let text1 = textA, text2 = textB;
    const a = linesToChars(text1, text2);
    text1 = a.chars1, text2 = a.chars2;
    const linearray = a.lineArray;
    let diffs = doDiff(text1, text2, {
        checkLines: !1,
        deadline: opts.deadline
    });
    charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([
        DIFF_EQUAL,
        ""
    ]);
    let pointer = 0, countDelete = 0, countInsert = 0, textDelete = "", textInsert = "";
    for(; pointer < diffs.length;){
        switch(diffs[pointer][0]){
            case DIFF_INSERT:
                countInsert++, textInsert += diffs[pointer][1];
                break;
            case DIFF_DELETE:
                countDelete++, textDelete += diffs[pointer][1];
                break;
            case DIFF_EQUAL:
                if (countDelete >= 1 && countInsert >= 1) {
                    diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;
                    const aa = doDiff(textDelete, textInsert, {
                        checkLines: !1,
                        deadline: opts.deadline
                    });
                    for(let j = aa.length - 1; j >= 0; j--)diffs.splice(pointer, 0, aa[j]);
                    pointer += aa.length;
                }
                countInsert = 0, countDelete = 0, textDelete = "", textInsert = "";
                break;
            default:
                throw new Error("Unknown diff operation.");
        }
        pointer++;
    }
    return diffs.pop(), diffs;
}
function computeDiff(text1, text2, opts) {
    let diffs;
    if (!text1) return [
        [
            DIFF_INSERT,
            text2
        ]
    ];
    if (!text2) return [
        [
            DIFF_DELETE,
            text1
        ]
    ];
    const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);
    if (i !== -1) return diffs = [
        [
            DIFF_INSERT,
            longtext.substring(0, i)
        ],
        [
            DIFF_EQUAL,
            shorttext
        ],
        [
            DIFF_INSERT,
            longtext.substring(i + shorttext.length)
        ]
    ], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;
    if (shorttext.length === 1) return [
        [
            DIFF_DELETE,
            text1
        ],
        [
            DIFF_INSERT,
            text2
        ]
    ];
    const halfMatch = findHalfMatch(text1, text2);
    if (halfMatch) {
        const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);
        return diffsA.concat([
            [
                DIFF_EQUAL,
                midCommon
            ]
        ], diffsB);
    }
    return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);
}
var __defProp$2 = Object.defineProperty, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value)=>key in obj ? __defProp$2(obj, key, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value
    }) : obj[key] = value, __spreadValues$2 = (a, b)=>{
    for(var prop in b || (b = {}))__hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
    if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b))__propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
    return a;
};
const DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;
function diff(textA, textB, opts) {
    if (textA === null || textB === null) throw new Error("Null input. (diff)");
    const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));
    return adjustDiffForSurrogatePairs(diffs), diffs;
}
function doDiff(textA, textB, options) {
    let text1 = textA, text2 = textB;
    if (text1 === text2) return text1 ? [
        [
            DIFF_EQUAL,
            text1
        ]
    ] : [];
    let commonlength = getCommonPrefix(text1, text2);
    const commonprefix = text1.substring(0, commonlength);
    text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);
    const commonsuffix = text1.substring(text1.length - commonlength);
    text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);
    let diffs = computeDiff(text1, text2, options);
    return commonprefix && diffs.unshift([
        DIFF_EQUAL,
        commonprefix
    ]), commonsuffix && diffs.push([
        DIFF_EQUAL,
        commonsuffix
    ]), diffs = cleanupMerge(diffs), diffs;
}
function createDeadLine(timeout) {
    let t = 1;
    return typeof timeout < "u" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;
}
function createInternalOpts(opts) {
    return __spreadValues$2({
        checkLines: !0,
        deadline: createDeadLine(opts.timeout || 1)
    }, opts);
}
function combineChar(data, char, dir) {
    return dir === 1 ? data + char : char + data;
}
function splitChar(data, dir) {
    return dir === 1 ? [
        data.substring(0, data.length - 1),
        data[data.length - 1]
    ] : [
        data.substring(1),
        data[0]
    ];
}
function hasSharedChar(diffs, i, j, dir) {
    return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];
}
function deisolateChar(diffs, i, dir) {
    const inv = dir === 1 ? -1 : 1;
    let insertIdx = null, deleteIdx = null, j = i + dir;
    for(; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir){
        const [op, text2] = diffs[j];
        if (text2.length !== 0) {
            if (op === DIFF_INSERT) {
                insertIdx === null && (insertIdx = j);
                continue;
            } else if (op === DIFF_DELETE) {
                deleteIdx === null && (deleteIdx = j);
                continue;
            } else if (op === DIFF_EQUAL) {
                if (insertIdx === null && deleteIdx === null) {
                    const [rest, char2] = splitChar(diffs[i][1], dir);
                    diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);
                    return;
                }
                break;
            }
        }
    }
    if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {
        const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);
        diffs[insertIdx][1] = insertText, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);
        return;
    }
    const [text, char] = splitChar(diffs[i][1], dir);
    diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [
        DIFF_INSERT,
        char
    ]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [
        DIFF_DELETE,
        char
    ]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);
}
function adjustDiffForSurrogatePairs(diffs) {
    for(let i = 0; i < diffs.length; i++){
        const [diffType, diffText] = diffs[i];
        if (diffText.length === 0) continue;
        const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];
        isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);
    }
    for(let i = 0; i < diffs.length; i++)diffs[i][1].length === 0 && diffs.splice(i, 1);
}
function cleanupSemantic(rawDiffs) {
    let diffs = rawDiffs.map((diff2)=>cloneDiff(diff2)), hasChanges = !1;
    const equalities = [];
    let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;
    for(; pointer < diffs.length;)diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [
        DIFF_DELETE,
        lastEquality
    ]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;
    for(hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length;){
        if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
            const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);
            overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                insertion.substring(0, overlapLength1)
            ]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                deletion.substring(0, overlapLength2)
            ]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;
        }
        pointer++;
    }
    return diffs;
}
const nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\s/, linebreakRegex = /[\r\n]/, blanklineEndRegex = /\n\r?\n$/, blanklineStartRegex = /^\r?\n\r?\n/;
function cleanupSemanticLossless(rawDiffs) {
    const diffs = rawDiffs.map((diff2)=>cloneDiff(diff2));
    function diffCleanupSemanticScore(one, two) {
        if (!one || !two) return 6;
        const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);
        return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;
    }
    let pointer = 1;
    for(; pointer < diffs.length - 1;){
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
            let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];
            const commonOffset = getCommonSuffix(equality1, edit);
            if (commonOffset) {
                const commonString = edit.substring(edit.length - commonOffset);
                equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;
            }
            let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
            for(; edit.charAt(0) === equality2.charAt(0);){
                equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);
                const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
                score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);
            }
            diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));
        }
        pointer++;
    }
    return diffs;
}
function cleanupMerge(rawDiffs) {
    let diffs = rawDiffs.map((diff2)=>cloneDiff(diff2));
    diffs.push([
        DIFF_EQUAL,
        ""
    ]);
    let pointer = 0, countDelete = 0, countInsert = 0, textDelete = "", textInsert = "", commonlength;
    for(; pointer < diffs.length;)switch(diffs[pointer][0]){
        case DIFF_INSERT:
            countInsert++, textInsert += diffs[pointer][1], pointer++;
            break;
        case DIFF_DELETE:
            countDelete++, textDelete += diffs[pointer][1], pointer++;
            break;
        case DIFF_EQUAL:
            countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength) : (diffs.splice(0, 0, [
                DIFF_EQUAL,
                textInsert.substring(0, commonlength)
            ]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [
                DIFF_DELETE,
                textDelete
            ]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [
                DIFF_INSERT,
                textInsert
            ]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = "", textInsert = "";
            break;
        default:
            throw new Error("Unknown diff operation");
    }
    diffs[diffs.length - 1][1] === "" && diffs.pop();
    let hasChanges = !1;
    for(pointer = 1; pointer < diffs.length - 1;)diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;
    return hasChanges && (diffs = cleanupMerge(diffs)), diffs;
}
function trueCount(...args) {
    return args.reduce((n, bool)=>n + (bool ? 1 : 0), 0);
}
function cleanupEfficiency(rawDiffs, editCost = 4) {
    let diffs = rawDiffs.map((diff2)=>cloneDiff(diff2)), hasChanges = !1;
    const equalities = [];
    let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;
    for(; pointer < diffs.length;)diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [
        DIFF_DELETE,
        lastEquality
    ]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;
    return hasChanges && (diffs = cleanupMerge(diffs)), diffs;
}
var __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value)=>key in obj ? __defProp$1(obj, key, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value
    }) : obj[key] = value, __spreadValues$1 = (a, b)=>{
    for(var prop in b || (b = {}))__hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
    if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b))__propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
    return a;
};
const DEFAULT_OPTIONS = {
    /**
   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).
   */ threshold: 0.5,
    /**
   * How far to search for a match (0 = exact location, 1000+ = broad match).
   * A match this many characters away from the expected location will add
   * 1.0 to the score (0.0 is a perfect match).
   */ distance: 1e3
};
function applyDefaults(options) {
    return __spreadValues$1(__spreadValues$1({}, DEFAULT_OPTIONS), options);
}
const MAX_BITS$1 = 32;
function bitap(text, pattern, loc, opts = {}) {
    if (pattern.length > MAX_BITS$1) throw new Error("Pattern too long for this browser.");
    const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);
    function getBitapScore(e, x) {
        const accuracy = e / pattern.length, proximity = Math.abs(loc - x);
        return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;
    }
    let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);
    bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));
    const matchmask = 1 << pattern.length - 1;
    bestLoc = -1;
    let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];
    for(let d = 0; d < pattern.length; d++){
        for(binMin = 0, binMid = binMax; binMin < binMid;)getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);
        binMax = binMid;
        let start = Math.max(1, loc - binMid + 1);
        const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);
        rd[finish + 1] = (1 << d) - 1;
        for(let j = finish; j >= start; j--){
            const charMatch = s[text.charAt(j - 1)];
            if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {
                const score = getBitapScore(d, j - 1);
                if (score <= scoreThreshold) if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc) start = Math.max(1, 2 * loc - bestLoc);
                else break;
            }
        }
        if (getBitapScore(d + 1, loc) > scoreThreshold) break;
        lastRd = rd;
    }
    return bestLoc;
}
function getAlphabetFromPattern(pattern) {
    const s = {};
    for(let i = 0; i < pattern.length; i++)s[pattern.charAt(i)] = 0;
    for(let i = 0; i < pattern.length; i++)s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
    return s;
}
function match(text, pattern, searchLocation) {
    if (text === null || pattern === null || searchLocation === null) throw new Error("Null input. (match())");
    const loc = Math.max(0, Math.min(searchLocation, text.length));
    if (text === pattern) return 0;
    if (text.length) {
        if (text.substring(loc, loc + pattern.length) === pattern) return loc;
    } else return -1;
    return bitap(text, pattern, loc);
}
function diffText1(diffs) {
    const text = [];
    for(let x = 0; x < diffs.length; x++)diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);
    return text.join("");
}
function diffText2(diffs) {
    const text = [];
    for(let x = 0; x < diffs.length; x++)diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);
    return text.join("");
}
function levenshtein(diffs) {
    let leven = 0, insertions = 0, deletions = 0;
    for(let x = 0; x < diffs.length; x++){
        const op = diffs[x][0], data = diffs[x][1];
        switch(op){
            case DIFF_INSERT:
                insertions += data.length;
                break;
            case DIFF_DELETE:
                deletions += data.length;
                break;
            case DIFF_EQUAL:
                leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;
                break;
            default:
                throw new Error("Unknown diff operation.");
        }
    }
    return leven += Math.max(insertions, deletions), leven;
}
function xIndex(diffs, loc) {
    let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;
    for(x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > loc)); x++)lastChars1 = chars1, lastChars2 = chars2;
    return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (loc - lastChars1);
}
function countUtf8Bytes(str) {
    let bytes = 0;
    for(let i = 0; i < str.length; i++){
        const codePoint = str.codePointAt(i);
        if (typeof codePoint > "u") throw new Error("Failed to get codepoint");
        bytes += utf8len(codePoint);
    }
    return bytes;
}
function adjustIndiciesToUcs2(patches, base, options = {}) {
    let byteOffset = 0, idx = 0;
    function advanceTo(target) {
        for(; byteOffset < target;){
            const codePoint = base.codePointAt(idx);
            if (typeof codePoint > "u") return idx;
            byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;
        }
        if (!options.allowExceedingIndices && byteOffset !== target) throw new Error("Failed to determine byte offset");
        return idx;
    }
    const adjusted = [];
    for (const patch of patches)adjusted.push({
        diffs: patch.diffs.map((diff2)=>cloneDiff(diff2)),
        start1: advanceTo(patch.start1),
        start2: advanceTo(patch.start2),
        utf8Start1: patch.utf8Start1,
        utf8Start2: patch.utf8Start2,
        length1: patch.length1,
        length2: patch.length2,
        utf8Length1: patch.utf8Length1,
        utf8Length2: patch.utf8Length2
    });
    return adjusted;
}
function utf8len(codePoint) {
    return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;
}
const MAX_BITS = 32, DEFAULT_MARGIN = 4;
function addPadding(patches, margin = DEFAULT_MARGIN) {
    const paddingLength = margin;
    let nullPadding = "";
    for(let x = 1; x <= paddingLength; x++)nullPadding += String.fromCharCode(x);
    for (const p of patches)p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;
    let patch = patches[0], diffs = patch.diffs;
    if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL) diffs.unshift([
        DIFF_EQUAL,
        nullPadding
    ]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;
    else if (paddingLength > diffs[0][1].length) {
        const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;
        diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;
    }
    if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL) diffs.push([
        DIFF_EQUAL,
        nullPadding
    ]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;
    else if (paddingLength > diffs[diffs.length - 1][1].length) {
        const extraLength = paddingLength - diffs[diffs.length - 1][1].length;
        diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;
    }
    return nullPadding;
}
function createPatchObject(start1, start2) {
    return {
        diffs: [],
        start1,
        start2,
        utf8Start1: start1,
        utf8Start2: start2,
        length1: 0,
        length2: 0,
        utf8Length1: 0,
        utf8Length2: 0
    };
}
function splitMax(patches, margin = DEFAULT_MARGIN) {
    const patchSize = MAX_BITS;
    for(let x = 0; x < patches.length; x++){
        if (patches[x].length1 <= patchSize) continue;
        const bigpatch = patches[x];
        patches.splice(x--, 1);
        let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = "";
        for(; bigpatch.diffs.length !== 0;){
            const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);
            let empty = !0;
            if (preContext !== "") {
                const precontextByteCount = countUtf8Bytes(preContext);
                patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([
                    DIFF_EQUAL,
                    preContext
                ]);
            }
            for(; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin;){
                const diffType = bigpatch.diffs[0][0];
                let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);
                if (diffType === DIFF_INSERT) {
                    patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;
                    const diff2 = bigpatch.diffs.shift();
                    diff2 && patch.diffs.push(diff2), empty = !1;
                } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([
                    diffType,
                    diffText
                ]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([
                    diffType,
                    diffText
                ]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));
            }
            preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);
            const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);
            postContext !== "" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([
                DIFF_EQUAL,
                postContext
            ])), empty || patches.splice(++x, 0, patch);
        }
    }
}
function apply(patches, originalText, opts = {}) {
    if (typeof patches == "string") throw new Error("Patches must be an array - pass the patch to `parsePatch()` first");
    let text = originalText;
    if (patches.length === 0) return [
        text,
        []
    ];
    const parsed = adjustIndiciesToUcs2(patches, text, {
        allowExceedingIndices: opts.allowExceedingIndices
    }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);
    text = nullPadding + text + nullPadding, splitMax(parsed, margin);
    let delta = 0;
    const results = [];
    for(let x = 0; x < parsed.length; x++){
        const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);
        let startLoc, endLoc = -1;
        if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1) results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;
        else {
            results[x] = !0, delta = startLoc - expectedLoc;
            let text2;
            if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2) text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);
            else {
                let diffs = diff(text1, text2, {
                    checkLines: !1
                });
                if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold) results[x] = !1;
                else {
                    diffs = cleanupSemanticLossless(diffs);
                    let index1 = 0, index2 = 0;
                    for(let y = 0; y < parsed[x].diffs.length; y++){
                        const mod = parsed[x].diffs[y];
                        mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);
                    }
                }
            }
        }
    }
    return text = text.substring(nullPadding.length, text.length - nullPadding.length), [
        text,
        results
    ];
}
var __defProp = Object.defineProperty, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value
    }) : obj[key] = value, __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))__hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b))__propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
    return a;
};
const DEFAULT_OPTS = {
    margin: 4
};
function getDefaultOpts(opts = {}) {
    return __spreadValues(__spreadValues({}, DEFAULT_OPTS), opts);
}
function make(a, b, options) {
    if (typeof a == "string" && typeof b == "string") {
        let diffs = diff(a, b, {
            checkLines: !0
        });
        return diffs.length > 2 && (diffs = cleanupSemantic(diffs), diffs = cleanupEfficiency(diffs)), _make(a, diffs, getDefaultOpts(options));
    }
    if (a && Array.isArray(a) && typeof b > "u") return _make(diffText1(a), a, getDefaultOpts(options));
    if (typeof a == "string" && b && Array.isArray(b)) return _make(a, b, getDefaultOpts(options));
    throw new Error("Unknown call format to make()");
}
function _make(textA, diffs, options) {
    if (diffs.length === 0) return [];
    const patches = [];
    let patch = createPatchObject(0, 0), patchDiffLength = 0, charCount1 = 0, charCount2 = 0, utf8Count1 = 0, utf8Count2 = 0, prepatchText = textA, postpatchText = textA;
    for(let x = 0; x < diffs.length; x++){
        const currentDiff = diffs[x], [diffType, diffText] = currentDiff, diffTextLength = diffText.length, diffByteLength = countUtf8Bytes(diffText);
        switch(!patchDiffLength && diffType !== DIFF_EQUAL && (patch.start1 = charCount1, patch.start2 = charCount2, patch.utf8Start1 = utf8Count1, patch.utf8Start2 = utf8Count2), diffType){
            case DIFF_INSERT:
                patch.diffs[patchDiffLength++] = currentDiff, patch.length2 += diffTextLength, patch.utf8Length2 += diffByteLength, postpatchText = postpatchText.substring(0, charCount2) + diffText + postpatchText.substring(charCount2);
                break;
            case DIFF_DELETE:
                patch.length1 += diffTextLength, patch.utf8Length1 += diffByteLength, patch.diffs[patchDiffLength++] = currentDiff, postpatchText = postpatchText.substring(0, charCount2) + postpatchText.substring(charCount2 + diffTextLength);
                break;
            case DIFF_EQUAL:
                diffTextLength <= 2 * options.margin && patchDiffLength && diffs.length !== x + 1 ? (patch.diffs[patchDiffLength++] = currentDiff, patch.length1 += diffTextLength, patch.length2 += diffTextLength, patch.utf8Length1 += diffByteLength, patch.utf8Length2 += diffByteLength) : diffTextLength >= 2 * options.margin && patchDiffLength && (addContext(patch, prepatchText, options), patches.push(patch), patch = createPatchObject(-1, -1), patchDiffLength = 0, prepatchText = postpatchText, charCount1 = charCount2, utf8Count1 = utf8Count2);
                break;
            default:
                throw new Error("Unknown diff type");
        }
        diffType !== DIFF_INSERT && (charCount1 += diffTextLength, utf8Count1 += diffByteLength), diffType !== DIFF_DELETE && (charCount2 += diffTextLength, utf8Count2 += diffByteLength);
    }
    return patchDiffLength && (addContext(patch, prepatchText, options), patches.push(patch)), patches;
}
function addContext(patch, text, opts) {
    if (text.length === 0) return;
    let pattern = text.substring(patch.start2, patch.start2 + patch.length1), padding = 0;
    for(; text.indexOf(pattern) !== text.lastIndexOf(pattern) && pattern.length < MAX_BITS - opts.margin - opts.margin;)padding += opts.margin, pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);
    padding += opts.margin;
    let prefixStart = patch.start2 - padding;
    prefixStart >= 1 && isLowSurrogate(text[prefixStart]) && prefixStart--;
    const prefix = text.substring(prefixStart, patch.start2);
    prefix && patch.diffs.unshift([
        DIFF_EQUAL,
        prefix
    ]);
    const prefixLength = prefix.length, prefixUtf8Length = countUtf8Bytes(prefix);
    let suffixEnd = patch.start2 + patch.length1 + padding;
    suffixEnd < text.length && isLowSurrogate(text[suffixEnd]) && suffixEnd++;
    const suffix = text.substring(patch.start2 + patch.length1, suffixEnd);
    suffix && patch.diffs.push([
        DIFF_EQUAL,
        suffix
    ]);
    const suffixLength = suffix.length, suffixUtf8Length = countUtf8Bytes(suffix);
    patch.start1 -= prefixLength, patch.start2 -= prefixLength, patch.utf8Start1 -= prefixUtf8Length, patch.utf8Start2 -= prefixUtf8Length, patch.length1 += prefixLength + suffixLength, patch.length2 += prefixLength + suffixLength, patch.utf8Length1 += prefixUtf8Length + suffixUtf8Length, patch.utf8Length2 += prefixUtf8Length + suffixUtf8Length;
}
const patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
function parse(textline) {
    if (!textline) return [];
    const patches = [], lines = textline.split(`
`);
    let textPointer = 0;
    for(; textPointer < lines.length;){
        const m = lines[textPointer].match(patchHeader);
        if (!m) throw new Error(`Invalid patch string: ${lines[textPointer]}`);
        const patch = createPatchObject(toInt(m[1]), toInt(m[3]));
        for(patches.push(patch), m[2] === "" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === "0" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === "" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === "0" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length;){
            const currentLine = lines[textPointer], sign = currentLine.charAt(0);
            if (sign === "@") break;
            if (sign === "") {
                textPointer++;
                continue;
            }
            let line;
            try {
                line = decodeURI(currentLine.slice(1));
            } catch (ex) {
                throw new Error(`Illegal escape in parse: ${currentLine}`);
            }
            const utf8Diff = countUtf8Bytes(line) - line.length;
            if (sign === "-") patch.diffs.push([
                DIFF_DELETE,
                line
            ]), patch.length1 -= utf8Diff;
            else if (sign === "+") patch.diffs.push([
                DIFF_INSERT,
                line
            ]), patch.length2 -= utf8Diff;
            else if (sign === " ") patch.diffs.push([
                DIFF_EQUAL,
                line
            ]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;
            else throw new Error(`Invalid patch mode "${sign}" in: ${line}`);
            textPointer++;
        }
    }
    return patches;
}
function toInt(num) {
    return parseInt(num, 10);
}
function stringify(patches) {
    return patches.map(stringifyPatch).join("");
}
function stringifyPatch(patch) {
    const { utf8Length1, utf8Length2, utf8Start1, utf8Start2, diffs } = patch;
    let coords1;
    utf8Length1 === 0 ? coords1 = `${utf8Start1},0` : utf8Length1 === 1 ? coords1 = `${utf8Start1 + 1}` : coords1 = `${utf8Start1 + 1},${utf8Length1}`;
    let coords2;
    utf8Length2 === 0 ? coords2 = `${utf8Start2},0` : utf8Length2 === 1 ? coords2 = `${utf8Start2 + 1}` : coords2 = `${utf8Start2 + 1},${utf8Length2}`;
    const text = [
        `@@ -${coords1} +${coords2} @@
`
    ];
    let op;
    for(let x = 0; x < diffs.length; x++){
        switch(diffs[x][0]){
            case DIFF_INSERT:
                op = "+";
                break;
            case DIFF_DELETE:
                op = "-";
                break;
            case DIFF_EQUAL:
                op = " ";
                break;
            default:
                throw new Error("Unknown patch operation.");
        }
        text[x + 1] = `${op + encodeURI(diffs[x][1])}
`;
    }
    return text.join("").replace(/%20/g, " ");
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/xstate/dist/raise-1db27a82.development.esm.js [app-client] (ecmascript) <export P as spawnChild>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "spawnChild": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$1db27a82$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["P"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$1db27a82$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/xstate/dist/raise-1db27a82.development.esm.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/xstate/dist/log-ef30c65f.development.esm.js [app-client] (ecmascript) <export s as sendParent>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "sendParent": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$ef30c65f$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/xstate/dist/log-ef30c65f.development.esm.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/mendoza/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "applyPatch": (()=>applyPatch),
    "incremental": (()=>incrementalPatcher)
});
const OPS = [
    "Value",
    "Copy",
    "Blank",
    "ReturnIntoArray",
    "ReturnIntoObject",
    "ReturnIntoObjectSameKey",
    "PushField",
    "PushElement",
    "PushParent",
    "Pop",
    "PushFieldCopy",
    "PushFieldBlank",
    "PushElementCopy",
    "PushElementBlank",
    "ReturnIntoObjectPop",
    "ReturnIntoObjectSameKeyPop",
    "ReturnIntoArrayPop",
    "ObjectSetFieldValue",
    "ObjectCopyField",
    "ObjectDeleteField",
    "ArrayAppendValue",
    "ArrayAppendSlice",
    "StringAppendString",
    "StringAppendSlice"
];
class Patcher {
    model;
    root;
    patch;
    i;
    inputStack;
    outputStack;
    constructor(model, root, patch){
        this.model = model, this.root = root, this.patch = patch, this.i = 0, this.inputStack = [], this.outputStack = [];
    }
    read() {
        return this.patch[this.i++];
    }
    process() {
        for(this.inputStack.push({
            value: this.root
        }), this.outputStack.push({
            value: this.root
        }); this.i < this.patch.length;){
            let opcode = this.read(), op = OPS[opcode];
            if (!op) throw new Error(`Unknown opcode: ${opcode}`);
            let processor = `process${op}`;
            this[processor].apply(this);
        }
        let entry = this.outputStack.pop();
        return this.finalizeOutput(entry);
    }
    inputEntry() {
        return this.inputStack[this.inputStack.length - 1];
    }
    inputKey(entry, idx) {
        return entry.keys || (entry.keys = this.model.objectGetKeys(entry.value).sort()), entry.keys[idx];
    }
    outputEntry() {
        return this.outputStack[this.outputStack.length - 1];
    }
    outputArray() {
        let entry = this.outputEntry();
        return entry.writeValue || (entry.writeValue = this.model.copyArray(entry.value)), entry.writeValue;
    }
    outputObject() {
        let entry = this.outputEntry();
        return entry.writeValue || (entry.writeValue = this.model.copyObject(entry.value)), entry.writeValue;
    }
    outputString() {
        let entry = this.outputEntry();
        return entry.writeValue || (entry.writeValue = this.model.copyString(entry.value)), entry.writeValue;
    }
    finalizeOutput(entry) {
        return entry.writeValue ? this.model.finalize(entry.writeValue) : entry.value;
    }
    // Processors:
    processValue() {
        let value = this.model.wrap(this.read());
        this.outputStack.push({
            value
        });
    }
    processCopy() {
        let input = this.inputEntry();
        this.outputStack.push({
            value: input.value
        });
    }
    processBlank() {
        this.outputStack.push({
            value: null
        });
    }
    processReturnIntoArray() {
        let entry = this.outputStack.pop(), result = this.finalizeOutput(entry), arr = this.outputArray();
        this.model.arrayAppendValue(arr, result);
    }
    processReturnIntoObject() {
        let key = this.read(), entry = this.outputStack.pop(), result = this.finalizeOutput(entry);
        result = this.model.markChanged(result);
        let obj = this.outputObject();
        this.model.objectSetField(obj, key, result);
    }
    processReturnIntoObjectSameKey() {
        let input = this.inputEntry(), entry = this.outputStack.pop(), result = this.finalizeOutput(entry), obj = this.outputObject();
        this.model.objectSetField(obj, input.key, result);
    }
    processPushField() {
        let idx = this.read(), entry = this.inputEntry(), key = this.inputKey(entry, idx), value = this.model.objectGetField(entry.value, key);
        this.inputStack.push({
            value,
            key
        });
    }
    processPushElement() {
        let idx = this.read(), entry = this.inputEntry(), value = this.model.arrayGetElement(entry.value, idx);
        this.inputStack.push({
            value
        });
    }
    processPop() {
        this.inputStack.pop();
    }
    processPushFieldCopy() {
        this.processPushField(), this.processCopy();
    }
    processPushFieldBlank() {
        this.processPushField(), this.processBlank();
    }
    processPushElementCopy() {
        this.processPushElement(), this.processCopy();
    }
    processPushElementBlank() {
        this.processPushElement(), this.processBlank();
    }
    processReturnIntoObjectPop() {
        this.processReturnIntoObject(), this.processPop();
    }
    processReturnIntoObjectSameKeyPop() {
        this.processReturnIntoObjectSameKey(), this.processPop();
    }
    processReturnIntoArrayPop() {
        this.processReturnIntoArray(), this.processPop();
    }
    processObjectSetFieldValue() {
        this.processValue(), this.processReturnIntoObject();
    }
    processObjectCopyField() {
        this.processPushField(), this.processCopy(), this.processReturnIntoObjectSameKey(), this.processPop();
    }
    processObjectDeleteField() {
        let idx = this.read(), entry = this.inputEntry(), key = this.inputKey(entry, idx), obj = this.outputObject();
        this.model.objectDeleteField(obj, key);
    }
    processArrayAppendValue() {
        let value = this.model.wrap(this.read()), arr = this.outputArray();
        this.model.arrayAppendValue(arr, value);
    }
    processArrayAppendSlice() {
        let left = this.read(), right = this.read(), str = this.outputArray(), val = this.inputEntry().value;
        this.model.arrayAppendSlice(str, val, left, right);
    }
    processStringAppendString() {
        let value = this.model.wrap(this.read()), str = this.outputString();
        this.model.stringAppendValue(str, value);
    }
    processStringAppendSlice() {
        let left = this.read(), right = this.read(), str = this.outputString(), val = this.inputEntry().value;
        this.model.stringAppendSlice(str, val, left, right);
    }
}
function utf8charSize(code) {
    return code >> 16 ? 4 : code >> 11 ? 3 : code >> 7 ? 2 : 1;
}
function utf8stringSize(str) {
    let b = 0;
    for(let i = 0; i < str.length; i++){
        let code = str.codePointAt(i), size = utf8charSize(code);
        size == 4 && i++, b += size;
    }
    return b;
}
function utf8resolveIndex(str, idx, start = 0) {
    let byteCount = start, ucsIdx = 0;
    for(ucsIdx = start; byteCount < idx; ucsIdx++){
        let code = str.codePointAt(ucsIdx), size = utf8charSize(code);
        size === 4 && ucsIdx++, byteCount += size;
    }
    return ucsIdx;
}
function commonPrefix(str, str2) {
    let len = Math.min(str.length, str2.length), b = 0;
    for(let i = 0; i < len;){
        let aPoint = str.codePointAt(i), bPoint = str2.codePointAt(i);
        if (aPoint !== bPoint) return b;
        let size = utf8charSize(aPoint);
        b += size, i += size === 4 ? 2 : 1;
    }
    return b;
}
function commonSuffix(str, str2, prefix = 0) {
    let len = Math.min(str.length, str2.length) - prefix, b = 0;
    for(let i = 0; i < len;){
        let aPoint = str.codePointAt(str.length - 1 - i), bPoint = str2.codePointAt(str2.length - 1 - i);
        if (aPoint !== bPoint) return b;
        let size = utf8charSize(aPoint);
        b += size, i += size === 4 ? 2 : 1;
    }
    return b;
}
class IncrementalModel {
    meta;
    constructor(meta){
        this.meta = meta;
    }
    wrap(data) {
        return this.wrapWithMeta(data, this.meta, this.meta);
    }
    wrapWithMeta(data, startMeta, endMeta = this.meta) {
        return {
            data,
            startMeta,
            endMeta
        };
    }
    asObject(value) {
        if (!value.content) {
            let fields = {};
            for (let [key, val] of Object.entries(value.data))fields[key] = this.wrapWithMeta(val, value.startMeta);
            value.content = {
                type: "object",
                fields
            };
        }
        return value.content;
    }
    asArray(value) {
        if (!value.content) {
            let elements = value.data.map((item)=>this.wrapWithMeta(item, value.startMeta)), metas = elements.map(()=>this.meta);
            value.content = {
                type: "array",
                elements,
                metas
            };
        }
        return value.content;
    }
    asString(value) {
        if (!value.content) {
            let str = value.data, part = {
                value: str,
                utf8size: utf8stringSize(str),
                uses: [],
                startMeta: value.startMeta,
                endMeta: value.endMeta
            };
            value.content = this.stringFromParts([
                part
            ]);
        }
        return value.content;
    }
    stringFromParts(parts) {
        let str = {
            type: "string",
            parts
        };
        for (let part of parts)part.uses.push(str);
        return str;
    }
    objectGetKeys(value) {
        return value.content ? Object.keys(value.content.fields) : Object.keys(value.data);
    }
    objectGetField(value, key) {
        return this.asObject(value).fields[key];
    }
    arrayGetElement(value, idx) {
        return this.asArray(value).elements[idx];
    }
    finalize(content) {
        return this.updateEndMeta(content), {
            content,
            startMeta: this.meta,
            endMeta: this.meta
        };
    }
    markChanged(value) {
        return this.wrap(unwrap(value));
    }
    updateEndMeta(content) {
        if (content.type == "string") for (let part of content.parts)part.endMeta = this.meta;
        else if (content.type === "array") for (let val of content.elements)val.content && val.endMeta !== this.meta && this.updateEndMeta(val.content), val.endMeta = this.meta;
        else for (let val of Object.values(content.fields))val.content && val.endMeta !== this.meta && this.updateEndMeta(val.content), val.endMeta = this.meta;
    }
    copyString(value) {
        if (value) {
            let other = this.asString(value);
            return this.stringFromParts(other.parts.slice());
        } else return {
            type: "string",
            parts: []
        };
    }
    copyObject(value) {
        let obj = {
            type: "object",
            fields: {}
        };
        if (value) {
            let other = this.asObject(value);
            Object.assign(obj.fields, other.fields);
        }
        return obj;
    }
    copyArray(value) {
        let arr = value ? this.asArray(value) : null, elements = arr ? arr.elements : [], metas = arr ? arr.metas : [];
        return {
            type: "array",
            elements,
            metas
        };
    }
    objectSetField(target, key, value) {
        target.fields[key] = value;
    }
    objectDeleteField(target, key) {
        delete target.fields[key];
    }
    arrayAppendValue(target, value) {
        target.elements.push(value), target.metas.push(this.meta);
    }
    arrayAppendSlice(target, source, left, right) {
        let arr = this.asArray(source), samePosition = arr.elements.length === left;
        if (target.elements.push(...arr.elements.slice(left, right)), samePosition) target.metas.push(...arr.metas.slice(left, right));
        else for(let i = left; i < right; i++)target.metas.push(this.meta);
    }
    stringAppendValue(target, value) {
        let str = this.asString(value);
        for (let part of str.parts)this.stringAppendPart(target, part);
    }
    stringAppendPart(target, part) {
        target.parts.push(part), part.uses.push(target);
    }
    resolveStringPart(str, from, len) {
        if (len === 0) return from;
        for(let i = from; i < str.parts.length; i++){
            let part = str.parts[i];
            if (len === part.utf8size) return i + 1;
            if (len < part.utf8size) return this.splitString(part, len), i + 1;
            len -= part.utf8size;
        }
        throw new Error("splitting string out of bounds");
    }
    splitString(part, idx) {
        let leftValue, rightValue, leftSize = idx, rightSize = part.utf8size - leftSize;
        if (part.utf8size !== part.value.length) {
            let byteCount = 0;
            for(idx = 0; byteCount < leftSize; idx++){
                let code = part.value.codePointAt(idx), size = utf8charSize(code);
                size === 4 && idx++, byteCount += size;
            }
        }
        leftValue = part.value.slice(0, idx), rightValue = part.value.slice(idx);
        let newPart = {
            value: rightValue,
            utf8size: rightSize,
            uses: part.uses.slice(),
            startMeta: part.startMeta,
            endMeta: part.endMeta
        };
        part.value = leftValue, part.utf8size = leftSize;
        for (let use of part.uses){
            let ndx = use.parts.indexOf(part);
            if (ndx === -1) throw new Error("bug: mismatch between string parts and use.");
            use.parts.splice(ndx + 1, 0, newPart);
        }
    }
    stringAppendSlice(target, source, left, right) {
        let str = this.asString(source), firstPart = this.resolveStringPart(str, 0, left), lastPart = this.resolveStringPart(str, firstPart, right - left);
        for(let i = firstPart; i < lastPart; i++){
            let part = str.parts[i];
            this.stringAppendPart(target, part);
        }
    }
}
function wrap(data, meta) {
    return {
        data,
        startMeta: meta,
        endMeta: meta
    };
}
function unwrap(value) {
    if (typeof value.data < "u") return value.data;
    let result, content = value.content;
    switch(content.type){
        case "string":
            result = content.parts.map((part)=>part.value).join("");
            break;
        case "array":
            result = content.elements.map((val)=>unwrap(val));
            break;
        case "object":
            {
                result = {};
                for (let [key, val] of Object.entries(content.fields))result[key] = unwrap(val);
            }
    }
    return value.data = result, result;
}
function getType(value) {
    return value.content ? value.content.type : Array.isArray(value.data) ? "array" : value.data === null ? "null" : typeof value.data;
}
function rebaseValue(left, right) {
    let leftType = getType(left), rightType = getType(right);
    if (leftType !== rightType) return right;
    let leftModel = new IncrementalModel(left.endMeta), rightModel = new IncrementalModel(right.endMeta);
    switch(leftType){
        case "object":
            {
                let leftObj = leftModel.asObject(left), rightObj = rightModel.asObject(right), identicalFieldCount = 0, leftFieldCount = Object.keys(leftObj.fields).length, rightFieldCount = Object.keys(rightObj.fields).length;
                for (let [key, rightVal] of Object.entries(rightObj.fields)){
                    let leftVal = leftObj.fields[key];
                    leftVal && (rightObj.fields[key] = rebaseValue(leftVal, rightVal), rightObj.fields[key] === leftVal && identicalFieldCount++);
                }
                return leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount ? left : right;
            }
        case "array":
            {
                let leftArr = leftModel.asArray(left), rightArr = rightModel.asArray(right);
                if (leftArr.elements.length !== rightArr.elements.length) break;
                let numRebased = 0;
                for(let i = 0; i < rightArr.elements.length; i++)rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]), rightArr.elements[i] !== leftArr.elements[i] && numRebased++;
                return numRebased === 0 ? left : right;
            }
        case "null":
        case "boolean":
        case "number":
            {
                if (unwrap(left) === unwrap(right)) return left;
                break;
            }
        case "string":
            {
                let leftRaw = unwrap(left), rightRaw = unwrap(right);
                if (leftRaw === rightRaw) return left;
                let result = rightModel.copyString(null), prefix = commonPrefix(leftRaw, rightRaw), suffix = commonSuffix(leftRaw, rightRaw, prefix), rightLen = utf8stringSize(rightRaw), leftLen = utf8stringSize(leftRaw);
                0 < prefix && rightModel.stringAppendSlice(result, left, 0, prefix), prefix < rightLen - suffix && rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix), leftLen - suffix < leftLen && rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);
                let value = rightModel.finalize(result);
                if (unwrap(value) !== rightRaw) throw new Error("incorrect string rebase");
                return value;
            }
    }
    return right;
}
function applyPatch$1(left, patch, startMeta) {
    let model = new IncrementalModel(startMeta);
    return new Patcher(model, left, patch).process();
}
var incrementalPatcher = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    applyPatch: applyPatch$1,
    getType,
    rebaseValue,
    unwrap,
    wrap
});
class SimpleModel {
    wrap(data) {
        return data;
    }
    finalize(b) {
        return Array.isArray(b) ? b : b.data;
    }
    markChanged(value) {
        return value;
    }
    objectGetKeys(value) {
        return Object.keys(value);
    }
    objectGetField(value, key) {
        return value[key];
    }
    arrayGetElement(value, idx) {
        return value[idx];
    }
    copyObject(value) {
        let res = {
            type: "object",
            data: {}
        };
        if (value !== null) for (let [key, val] of Object.entries(value))res.data[key] = val;
        return res;
    }
    copyArray(value) {
        return value === null ? [] : value.slice();
    }
    copyString(value) {
        return {
            type: "string",
            data: value === null ? "" : value
        };
    }
    objectSetField(target, key, value) {
        target.data[key] = value;
    }
    objectDeleteField(target, key) {
        delete target.data[key];
    }
    arrayAppendValue(target, value) {
        target.push(value);
    }
    arrayAppendSlice(target, source, left, right) {
        target.push(...source.slice(left, right));
    }
    stringAppendSlice(target, source, left, right) {
        const sourceString = source, leftPos = utf8resolveIndex(sourceString, left), rightPos = utf8resolveIndex(sourceString, right, leftPos);
        target.data += sourceString.slice(leftPos, rightPos);
    }
    stringAppendValue(target, value) {
        target.data += value;
    }
}
function applyPatch(left, patch) {
    let root = left;
    return new Patcher(new SimpleModel(), root, patch).process();
}
;
 //# sourceMappingURL=index.js.map
}}),
}]);

//# sourceMappingURL=node_modules_dcc376._.js.map